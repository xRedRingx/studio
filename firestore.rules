rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // =====================================================================
    // Helper Functions
    // =====================================================================

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function getUserData(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    function getUserRole(userId) {
      return getUserData(userId).role;
    }

    function incomingData() {
      return request.resource.data;
    }

    function existingData() {
      return resource.data;
    }

    function isNow(field) {
      return field is timestamp && field == request.time;
    }
    
    function isTimestamp(field) {
        return field is timestamp;
    }

    function isMap(data) {
        return data is map;
    }

    function hasExactly(data, keys) {
        return data.keys().hasAll(keys) && data.keys().hasOnly(keys);
    }

    function hasAtLeast(data, keys) {
        return data.keys().hasAll(keys);
    }
    
    // =====================================================================
    // User Profile Rules
    // =====================================================================
    match /users/{userId} {
      allow read: if isSignedIn();
      
      allow create: if isSignedIn() && isOwner(userId)
                    && hasAtLeast(incomingData(), ['role', 'firstName', 'lastName', 'email', 'createdAt', 'updatedAt'])
                    && incomingData().firstName is string && incomingData().lastName is string
                    && incomingData().email is string
                    && (incomingData().role == 'customer' || incomingData().role == 'barber')
                    && isNow(incomingData().createdAt) && isNow(incomingData().updatedAt)
                    && (!('isAcceptingBookings' in incomingData()) || incomingData().isAcceptingBookings is bool);

      allow update: if isSignedIn() && isOwner(userId)
                    && !('role' in incomingData()) // Cannot change role
                    && !('email' in incomingData()) // Cannot change email
                    && !('createdAt' in incomingData()) // Cannot change creation date
                    && isNow(incomingData().updatedAt)
                    && (incomingData().firstName is string && incomingData().lastName is string)
                    && (!('isAcceptingBookings' in incomingData()) || incomingData().isAcceptingBookings is bool);
    }

    // =====================================================================
    // Services Rules
    // =====================================================================
    match /services/{serviceId} {
      allow read: if true;

      allow create: if isSignedIn() && getUserRole(request.auth.uid) == 'barber'
                    && hasExactly(incomingData(), ['barberId', 'name', 'price', 'duration', 'createdAt', 'updatedAt'])
                    && incomingData().barberId == request.auth.uid
                    && incomingData().name is string && incomingData().name.size() > 0
                    && incomingData().price is number && incomingData().price >= 0
                    && incomingData().duration is number && incomingData().duration > 0
                    && isNow(incomingData().createdAt) && isNow(incomingData().updatedAt);

      allow update: if isSignedIn() && getUserRole(request.auth.uid) == 'barber'
                    && existingData().barberId == request.auth.uid
                    && !('barberId' in incomingData()) && !('createdAt' in incomingData())
                    && incomingData().name is string && incomingData().name.size() > 0
                    && incomingData().price is number && incomingData().price >= 0
                    && incomingData().duration is number && incomingData().duration > 0
                    && isNow(incomingData().updatedAt);
      
      allow delete: if isSignedIn() && getUserRole(request.auth.uid) == 'barber' && existingData().barberId == request.auth.uid;
    }

    // =====================================================================
    // Barber Schedule Rules
    // =====================================================================
    match /barberSchedules/{barberId} {
        allow read: if true;
        allow write: if isSignedIn() && request.auth.uid == barberId && getUserRole(request.auth.uid) == 'barber'
                    && hasAtLeast(incomingData(), ['schedule', 'updatedAt'])
                    && incomingData().schedule is list && incomingData().schedule.size() == 7
                    // Basic check on the first element as a sample validation
                    && incomingData().schedule[0].day is string
                    && incomingData().schedule[0].isOpen is bool
                    && isNow(incomingData().updatedAt);

        // Subcollection for unavailable dates
        match /unavailableDates/{dateId} {
            allow read: if true;
            allow create: if isSignedIn() && request.auth.uid == barberId && getUserRole(request.auth.uid) == 'barber'
                        && hasAtLeast(incomingData(), ['date', 'createdAt'])
                        && incomingData().date == dateId
                        && (!('reason' in incomingData()) || incomingData().reason is string)
                        && isNow(incomingData().createdAt);

            allow delete: if isSignedIn() && request.auth.uid == barberId && getUserRole(request.auth.uid) == 'barber';
        }
    }

    // =====================================================================
    // Appointment Rules
    // =====================================================================
    function isAppointmentOwner() {
        // This function will be called in an 'update' context, so 'resource.data' (existingData) is appropriate
        return existingData().customerId == request.auth.uid;
    }

    function isBarberOfAppointment() {
        // This function will be called in an 'update' context, so 'resource.data' (existingData) is appropriate
        return existingData().barberId == request.auth.uid;
    }

    function isValidAppointmentStatusTransition(fromStatus, toStatus) {
        // Customer transitions
        return (isAppointmentOwner() && (
                    (fromStatus == 'upcoming' && toStatus == 'cancelled') ||
                    (fromStatus == 'upcoming' && toStatus == 'customer-initiated-check-in') ||
                    (fromStatus == 'barber-initiated-check-in' && toStatus == 'in-progress') || 
                    (fromStatus == 'in-progress' && toStatus == 'customer-initiated-completion') ||
                    (fromStatus == 'barber-initiated-completion' && toStatus == 'completed') 
                )) ||
               // Barber transitions
               (isBarberOfAppointment() && (
                    (fromStatus == 'upcoming' && toStatus == 'barber-initiated-check-in') ||
                    (fromStatus == 'upcoming' && toStatus == 'cancelled') || // Barber can also cancel
                    (fromStatus == 'customer-initiated-check-in' && toStatus == 'in-progress') ||
                    (fromStatus == 'in-progress' && toStatus == 'barber-initiated-completion') ||
                    (fromStatus == 'customer-initiated-completion' && toStatus == 'completed') ||
                    // Barber managing walk-in
                    (existingData().customerId == null && fromStatus == 'in-progress' && toStatus == 'completed')
               ));
    }

    match /appointments/{appointmentId} {
      allow read: if isSignedIn();

      allow create: if isSignedIn() && getUserRole(request.auth.uid) == 'customer'
                    && incomingData().customerId == request.auth.uid
                    && hasAtLeast(incomingData(), ['barberId', 'barberName', 'customerId', 'customerName', 'serviceId', 'serviceName', 'price', 'date', 'startTime', 'endTime', 'status', 'createdAt', 'updatedAt'])
                    && incomingData().barberId is string
                    && incomingData().customerId is string // Ensure customerId is a string, not null for booked appts
                    && incomingData().serviceId is string
                    && incomingData().date is string
                    && incomingData().startTime is string
                    && incomingData().status == 'upcoming'
                    && isNow(incomingData().createdAt) && isNow(incomingData().updatedAt)
                    && incomingData().customerCheckedInAt == null
                    && incomingData().barberCheckedInAt == null
                    && incomingData().serviceActuallyStartedAt == null
                    && incomingData().customerMarkedDoneAt == null
                    && incomingData().barberMarkedDoneAt == null
                    && incomingData().serviceActuallyCompletedAt == null
                    // Check if barber is accepting bookings
                    && getUserData(incomingData().barberId).get('isAcceptingBookings', true) == true;

      allow update: if isSignedIn() && isNow(incomingData().updatedAt)
                    && isValidAppointmentStatusTransition(existingData().status, incomingData().status);
                    // More granular field checks based on status transition would be added here

      allow delete: if false; // Appointments should be 'cancelled' via update, not deleted
    }
  }
}

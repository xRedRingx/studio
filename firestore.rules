
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper: Is the user authenticated?
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper: Get user's role from their Firestore document.
    function getUserRole(userId) {
      // It's good practice to check if the document exists before accessing .data
      return exists(/databases/$(database)/documents/users/$(userId)) &&
             get(/databases/$(database)/documents/users/$(userId)).data.role;
    }

    // Helper: Is the user the owner of the document?
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // --- Users Collection ---
    match /users/{userId} {
      allow read: if isAuthenticated() && (
                    isOwner(userId) || 
                    (getUserRole(request.auth.uid) == 'customer' && get(/databases/$(database)/documents/users/$(userId)).data.role == 'barber') // Customers can read barber profiles
                  );
      allow create: if request.auth.uid == userId &&
                       request.resource.data.uid == userId &&
                       request.resource.data.email == request.auth.token.email &&
                       (request.resource.data.role == 'customer' || request.resource.data.role == 'barber') &&
                       request.resource.data.firstName is string && request.resource.data.lastName is string &&
                       (request.resource.data.phoneNumber == null || request.resource.data.phoneNumber is string) &&
                       (request.resource.data.address == null || request.resource.data.address is string) &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time &&
                       (request.resource.data.role == 'barber' ? 
                          request.resource.data.isAcceptingBookings is bool : 
                          !('isAcceptingBookings' in request.resource.data.keys())) && // Customers should not send this field
                       (request.resource.data.fcmToken == null || request.resource.data.fcmToken is string);

      allow update: if isAuthenticated() && isOwner(userId) &&
                       // Immutable fields
                       request.resource.data.uid == resource.data.uid &&
                       request.resource.data.email == resource.data.email &&
                       request.resource.data.role == resource.data.role &&
                       request.resource.data.createdAt == resource.data.createdAt &&
                       // Standard updatable fields & type checks
                       request.resource.data.updatedAt == request.time &&
                       request.resource.data.firstName is string &&
                       request.resource.data.lastName is string &&
                       (request.resource.data.phoneNumber == null || request.resource.data.phoneNumber is string) &&
                       (request.resource.data.address == null || request.resource.data.address is string) &&
                       // Conditional field type checks IF they are being changed
                       ( !('isAcceptingBookings' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.isAcceptingBookings is bool ) &&
                       ( !('fcmToken' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.fcmToken == null || request.resource.data.fcmToken is string ) &&
                       // Role-based restriction on 'isAcceptingBookings' modification
                       ( resource.data.role == 'barber' || !('isAcceptingBookings' in request.resource.data.diff(resource.data).affectedKeys()) ) &&
                       // Overall check of which fields are being modified
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['firstName', 'lastName', 'phoneNumber', 'address', 'updatedAt', 'isAcceptingBookings', 'fcmToken', 'displayName', 'emailVerified']); // displayName, emailVerified might be updated by Firebase Auth triggers
    }

    // --- Services Collection ---
    match /services/{serviceId} {
      allow read: if true;
      allow create: if isAuthenticated() && getUserRole(request.auth.uid) == 'barber' &&
                       request.resource.data.barberId == request.auth.uid &&
                       request.resource.data.name is string && request.resource.data.name.size() > 0 && request.resource.data.name.size() <= 100 &&
                       request.resource.data.price is number && request.resource.data.price >= 0 && request.resource.data.price <= 10000 &&
                       request.resource.data.duration is number && request.resource.data.duration >= 5 && request.resource.data.duration <= 720 &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time;
      allow update: if isAuthenticated() && getUserRole(request.auth.uid) == 'barber' &&
                       resource.data.barberId == request.auth.uid && // Only owner barber can update
                       request.resource.data.barberId == resource.data.barberId && // BarberId cannot change
                       request.resource.data.name is string && request.resource.data.name.size() > 0 && request.resource.data.name.size() <= 100 &&
                       request.resource.data.price is number && request.resource.data.price >= 0 && request.resource.data.price <= 10000 &&
                       request.resource.data.duration is number && request.resource.data.duration >= 5 && request.resource.data.duration <= 720 &&
                       request.resource.data.createdAt == resource.data.createdAt && // createdAt cannot change
                       request.resource.data.updatedAt == request.time;
      allow delete: if isAuthenticated() && getUserRole(request.auth.uid) == 'barber' &&
                       resource.data.barberId == request.auth.uid;
    }

    // --- Barber Schedules Collection ---
    match /barberSchedules/{barberId} {
      allow read: if isAuthenticated();
      allow create, update: if isAuthenticated() && isOwner(barberId) && getUserRole(barberId) == 'barber' &&
                                request.resource.data.barberId == barberId &&
                                request.resource.data.schedule is list && // Add detailed validation for schedule items if needed
                                request.resource.data.updatedAt == request.time;
      match /unavailableDates/{dateId} {
        allow read: if isAuthenticated();
        allow create: if isAuthenticated() && isOwner(barberId) && getUserRole(barberId) == 'barber' &&
                         request.resource.data.barberId == barberId &&
                         request.resource.data.date == dateId &&
                         request.resource.data.date is string &&
                         (request.resource.data.reason == null || (request.resource.data.reason is string && request.resource.data.reason.size() <= 100)) &&
                         request.resource.data.createdAt == request.time;
        allow delete: if isAuthenticated() && isOwner(barberId) && getUserRole(barberId) == 'barber';
      }
    }

    // --- Appointments Collection ---
    function isValidAppointmentBaseStructure(data) {
      return data.barberId is string && data.barberName is string &&
             (data.customerId == null || data.customerId is string) && data.customerName is string &&
             data.serviceId is string && data.serviceName is string &&
             data.price is number && data.price >= 0 &&
             data.date is string && data.startTime is string && data.endTime is string &&
             data.status is string && data.createdAt is timestamp && data.updatedAt is timestamp &&
             (data.customerCheckedInAt == null || data.customerCheckedInAt is timestamp) &&
             (data.barberCheckedInAt == null || data.barberCheckedInAt is timestamp) &&
             (data.serviceActuallyStartedAt == null || data.serviceActuallyStartedAt is timestamp) &&
             (data.customerMarkedDoneAt == null || data.customerMarkedDoneAt is timestamp) &&
             (data.barberMarkedDoneAt == null || data.barberMarkedDoneAt is timestamp) &&
             (data.serviceActuallyCompletedAt == null || data.serviceActuallyCompletedAt is timestamp);
    }
    
    function areAppointmentCreationTimestampsValid(data, isWalkIn) {
        let expectedCustomerCheckedInAt = isWalkIn ? request.time : null;
        let expectedBarberCheckedInAt = isWalkIn ? request.time : null;
        let expectedServiceActuallyStartedAt = isWalkIn ? request.time : null;

        return data.createdAt == request.time && data.updatedAt == request.time &&
               data.customerCheckedInAt == expectedCustomerCheckedInAt &&
               data.barberCheckedInAt == expectedBarberCheckedInAt &&
               data.serviceActuallyStartedAt == expectedServiceActuallyStartedAt &&
               data.customerMarkedDoneAt == null &&
               data.barberMarkedDoneAt == null &&
               data.serviceActuallyCompletedAt == null;
    }

    function areAppointmentFieldsImmutable(reqData, resData) {
        return reqData.barberId == resData.barberId &&
               reqData.barberName == resData.barberName &&
               reqData.customerId == resData.customerId &&
               reqData.customerName == resData.customerName &&
               reqData.serviceId == resData.serviceId &&
               reqData.serviceName == resData.serviceName &&
               reqData.price == resData.price &&
               reqData.date == resData.date &&
               reqData.startTime == resData.startTime &&
               reqData.endTime == resData.endTime &&
               reqData.createdAt == resData.createdAt;
    }
    
    function canCustomerUpdateAppointment(reqData, resData) {
      let currentStatus = resData.status;
      let nextStatus = reqData.status;
      let affectedKeys = reqData.diff(resData).affectedKeys();

      // Customer checks in for an upcoming appointment
      if (currentStatus == 'upcoming' && nextStatus == 'customer-initiated-check-in') {
        return reqData.customerCheckedInAt == request.time && 
               affectedKeys.hasOnly(['status', 'updatedAt', 'customerCheckedInAt']);
      }
      // Customer confirms start after barber check-in, or mutual check-in leads to in-progress
      if (nextStatus == 'in-progress' && 
          (currentStatus == 'barber-initiated-check-in' || (currentStatus == 'upcoming' && resData.barberCheckedInAt != null))) {
        return reqData.customerCheckedInAt == request.time && reqData.serviceActuallyStartedAt == request.time &&
               affectedKeys.hasOnly(['status', 'updatedAt', 'customerCheckedInAt', 'serviceActuallyStartedAt']);
      }
      // Customer marks service as done
      if (currentStatus == 'in-progress' && nextStatus == 'customer-initiated-completion') {
        return reqData.customerMarkedDoneAt == request.time && 
               affectedKeys.hasOnly(['status', 'updatedAt', 'customerMarkedDoneAt']);
      }
      // Customer confirms completion after barber marked done, or mutual completion leads to completed
      if (nextStatus == 'completed' && 
          (currentStatus == 'barber-initiated-completion' || (currentStatus == 'in-progress' && resData.barberMarkedDoneAt != null))) {
        return reqData.customerMarkedDoneAt == request.time && reqData.serviceActuallyCompletedAt == request.time &&
               affectedKeys.hasOnly(['status', 'updatedAt', 'customerMarkedDoneAt', 'serviceActuallyCompletedAt']);
      }
      // Customer cancels appointment
      if (nextStatus == 'cancelled' && (currentStatus == 'upcoming' || currentStatus == 'customer-initiated-check-in' || currentStatus == 'barber-initiated-check-in')) {
        return affectedKeys.hasOnly(['status', 'updatedAt']);
      }
      return false;
    }

    function canBarberUpdateAppointment(reqData, resData) {
      let currentStatus = resData.status;
      let nextStatus = reqData.status;
      let isWalkIn = resData.customerId == null;
      let affectedKeys = reqData.diff(resData).affectedKeys();

      // Barber records customer arrival
      if (currentStatus == 'upcoming' && nextStatus == 'barber-initiated-check-in') {
        return reqData.barberCheckedInAt == request.time && 
               affectedKeys.hasOnly(['status', 'updatedAt', 'barberCheckedInAt']);
      }
      // Barber confirms start after customer check-in, or mutual check-in leads to in-progress
      if (nextStatus == 'in-progress' && 
          (currentStatus == 'customer-initiated-check-in' || (currentStatus == 'upcoming' && resData.customerCheckedInAt != null))) {
        return reqData.barberCheckedInAt == request.time && reqData.serviceActuallyStartedAt == request.time &&
               affectedKeys.hasOnly(['status', 'updatedAt', 'barberCheckedInAt', 'serviceActuallyStartedAt']);
      }
      // Barber starts a walk-in appointment they created (which was 'barber-initiated-check-in' or directly 'in-progress' based on creation rule)
      if (isWalkIn && (currentStatus == 'barber-initiated-check-in' || currentStatus == 'in-progress') && nextStatus == 'in-progress') {
          // If already 'in-progress', this allows updating updatedAt only, which is fine.
          // If 'barber-initiated-check-in', it moves to 'in-progress'
          return (currentStatus == 'barber-initiated-check-in' ? reqData.serviceActuallyStartedAt == request.time : reqData.serviceActuallyStartedAt == resData.serviceActuallyStartedAt) &&
                 affectedKeys.hasOnly(['status', 'updatedAt', 'serviceActuallyStartedAt']);
      }
      // Barber marks service as done
      if (currentStatus == 'in-progress' && nextStatus == 'barber-initiated-completion') {
        return reqData.barberMarkedDoneAt == request.time && 
               affectedKeys.hasOnly(['status', 'updatedAt', 'barberMarkedDoneAt']);
      }
      // Barber confirms completion after customer marked done, or marks walk-in as completed directly
      if (nextStatus == 'completed' &&
          (currentStatus == 'customer-initiated-completion' || (currentStatus == 'in-progress' /* covers walk-in direct completion */))) {
        return reqData.barberMarkedDoneAt == request.time && reqData.serviceActuallyCompletedAt == request.time &&
               affectedKeys.hasOnly(['status', 'updatedAt', 'barberMarkedDoneAt', 'serviceActuallyCompletedAt']);
      }
      return false;
    }

    match /appointments/{appointmentId} {
      allow read: if isAuthenticated() &&
                     (request.auth.uid == resource.data.customerId || request.auth.uid == resource.data.barberId);

      allow create: if isAuthenticated() &&
                       isValidAppointmentBaseStructure(request.resource.data) &&
                       ( (getUserRole(request.auth.uid) == 'customer' &&
                          request.auth.uid == request.resource.data.customerId &&
                          request.resource.data.status == 'upcoming' &&
                          areAppointmentCreationTimestampsValid(request.resource.data, false)
                         ) ||
                         (getUserRole(request.auth.uid) == 'barber' &&
                          request.auth.uid == request.resource.data.barberId &&
                          request.resource.data.customerId == null && // Walk-in specific
                          request.resource.data.status == 'in-progress' && // Walk-ins start as in-progress
                          areAppointmentCreationTimestampsValid(request.resource.data, true)
                         )
                       );

      allow update: if isAuthenticated() &&
                       isValidAppointmentBaseStructure(request.resource.data) && // Validates overall structure and types of incoming data
                       areAppointmentFieldsImmutable(request.resource.data, resource.data) && // Checks immutable fields haven't changed
                       request.resource.data.updatedAt == request.time && // Common update condition
                       ( (request.auth.uid == resource.data.customerId && getUserRole(request.auth.uid) == 'customer' && 
                          canCustomerUpdateAppointment(request.resource.data, resource.data)) ||
                         (request.auth.uid == resource.data.barberId && getUserRole(request.auth.uid) == 'barber' &&
                          canBarberUpdateAppointment(request.resource.data, resource.data))
                       );
      // No direct delete for appointments; use 'cancelled' status.
    }
  }
}

    
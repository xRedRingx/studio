
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isUser(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function getRole(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data.role;
    }

    function incomingData() {
      return request.resource.data;
    }

    function existingData() {
      return resource.data;
    }

    function isFieldsChanged(allowedFields) {
      let changedKeys = request.resource.data.diff(resource.data).affectedKeys();
      return changedKeys.hasOnly(allowedFields);
    }

    // User Profile Rules
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && request.auth.uid == userId &&
                     incomingData().uid == userId &&
                     (incomingData().role == 'customer' || incomingData().role == 'barber') &&
                     incomingData().createdAt == request.time && // Ensure createdAt is set by server if using serverTimestamp, or validated if client-set
                     incomingData().updatedAt == request.time && // Ensure updatedAt is set by server if using serverTimestamp, or validated if client-set
                     (!('isAcceptingBookings' in incomingData()) || incomingData().isAcceptingBookings == true || incomingData().role != 'barber') && // Default true or not present for customer
                     incomingData().firstName is string && incomingData().firstName.size() > 0 &&
                     incomingData().lastName is string && incomingData().lastName.size() > 0 &&
                     incomingData().email == request.auth.email &&
                     (incomingData().phoneNumber == null || (incomingData().phoneNumber is string && incomingData().phoneNumber.matches('^\\+[1-9]\\d{1,14}$'))) &&
                     (incomingData().address == null || (incomingData().address is string && incomingData().address.size() <= 100)) &&
                     incomingData().fcmToken == null;


      allow update: if isUser(userId) &&
                     isFieldsChanged(['firstName', 'lastName', 'phoneNumber', 'address', 'isAcceptingBookings', 'fcmToken', 'updatedAt']) &&
                     incomingData().updatedAt == request.time &&
                     (incomingData().firstName is string && incomingData().firstName.size() > 0) &&
                     (incomingData().lastName is string && incomingData().lastName.size() > 0) &&
                     (incomingData().phoneNumber == null || (incomingData().phoneNumber is string && incomingData().phoneNumber.matches('^\\+[1-9]\\d{1,14}$'))) &&
                     (incomingData().address == null || (incomingData().address is string && incomingData().address.size() <= 100)) &&
                     // Prevent changing email or role via this update
                     incomingData().email == existingData().email &&
                     incomingData().role == existingData().role &&
                     incomingData().uid == existingData().uid &&
                     // isAcceptingBookings can only be changed by barbers
                     (existingData().role != 'barber' || incomingData().isAcceptingBookings is bool) &&
                     (incomingData().fcmToken == null || incomingData().fcmToken is string);
    }

    // Services Rules
    match /services/{serviceId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && getRole(request.auth.uid) == 'barber' &&
                     incomingData().barberId == request.auth.uid &&
                     incomingData().name is string && incomingData().name.size() > 0 && incomingData().name.size() <= 100 &&
                     incomingData().price is number && incomingData().price >= 0 &&
                     incomingData().duration is number && incomingData().duration >= 5 && incomingData().duration <= 720 &&
                     incomingData().createdAt == request.time &&
                     incomingData().updatedAt == request.time;

      allow update: if isSignedIn() && getRole(request.auth.uid) == 'barber' &&
                     existingData().barberId == request.auth.uid &&
                     isFieldsChanged(['name', 'price', 'duration', 'updatedAt']) &&
                     incomingData().name is string && incomingData().name.size() > 0 && incomingData().name.size() <= 100 &&
                     incomingData().price is number && incomingData().price >= 0 &&
                     incomingData().duration is number && incomingData().duration >= 5 && incomingData().duration <= 720 &&
                     incomingData().updatedAt == request.time &&
                     // Ensure barberId and createdAt are not changed
                     incomingData().barberId == existingData().barberId &&
                     incomingData().createdAt == existingData().createdAt;

      allow delete: if isSignedIn() && getRole(request.auth.uid) == 'barber' &&
                     existingData().barberId == request.auth.uid;
    }

    // Barber Schedules Rules
    match /barberSchedules/{barberId} {
      allow read: if isSignedIn(); // Customers need to read this for availability
      allow create, update: if isSignedIn() && getRole(request.auth.uid) == 'barber' &&
                               request.auth.uid == barberId &&
                               incomingData().barberId == barberId &&
                               incomingData().schedule is list &&
                               incomingData().schedule.size() == 7 && // Ensure all 7 days are present
                               // Add validation for each item in schedule array if needed (e.g., day name, format of time)
                               incomingData().updatedAt == request.time;
      match /unavailableDates/{dateId} {
        allow read: if isSignedIn(); // Customers need to read this for availability
        allow create: if isSignedIn() && getRole(request.auth.uid) == 'barber' &&
                         request.auth.uid == barberId && // barberId from parent document
                         incomingData().barberId == barberId &&
                         incomingData().date == dateId && // Ensure doc ID matches date field
                         incomingData().date.matches('^\\d{4}-\\d{2}-\\d{2}$') &&
                         (incomingData().reason == null || (incomingData().reason is string && incomingData().reason.size() <= 100)) &&
                         incomingData().createdAt == request.time;
        allow delete: if isSignedIn() && getRole(request.auth.uid) == 'barber' &&
                         request.auth.uid == barberId;
      }
    }

    // Helper: Is the requester the customer of the appointment?
    function isAppointmentOwner(data) {
      return data.customerId == request.auth.uid;
    }

    // Helper: Is the requester the barber of the appointment?
    function isBarberOfAppointment(data) {
      return data.barberId == request.auth.uid;
    }

    // Helper: Basic data validation for appointment on create
    function isValidAppointmentBaseDataForCreate(data) {
      return data.barberId is string &&
             data.barberName is string &&
             (data.customerId == null || data.customerId is string) && // customerId can be null for walk-ins
             data.customerName is string &&
             data.serviceId is string &&
             data.serviceName is string &&
             data.price is number && data.price >= 0 &&
             data.date is string && data.date.matches('^\\d{4}-\\d{2}-\\d{2}$') &&
             data.startTime is string && data.startTime.matches('^(0[1-9]|1[0-2]):[0-5][0-9] (AM|PM)$') &&
             data.endTime is string && data.endTime.matches('^(0[1-9]|1[0-2]):[0-5][0-9] (AM|PM)$');
    }
    
    function areTimestampsValidForCreate(data) {
      let isWalkIn = data.customerId == null;
      return data.createdAt is timestamp && data.createdAt == request.time &&
             data.updatedAt is timestamp && data.updatedAt == request.time &&
             // For booked appointments, these are null on creation
             (isWalkIn || data.customerCheckedInAt == null) &&
             (isWalkIn || data.barberCheckedInAt == null) &&
             (isWalkIn || data.serviceActuallyStartedAt == null) &&
             // For walk-ins, these are set at creation time
             (!isWalkIn || (data.customerCheckedInAt == request.time && data.barberCheckedInAt == request.time && data.serviceActuallyStartedAt == request.time)) &&
             data.customerMarkedDoneAt == null &&
             data.barberMarkedDoneAt == null &&
             data.serviceActuallyCompletedAt == null;
    }

    function hasOnlyAllowedFieldsForCreate(data) {
        let allowed = ['barberId', 'barberName', 'customerId', 'customerName', 'serviceId', 'serviceName', 'price', 'date', 'startTime', 'endTime', 'status', 'createdAt', 'updatedAt', 'customerCheckedInAt', 'barberCheckedInAt', 'serviceActuallyStartedAt', 'customerMarkedDoneAt', 'barberMarkedDoneAt', 'serviceActuallyCompletedAt'];
        return data.keys().hasOnly(allowed);
    }

    function isCreatingOwnAppointmentAsCustomer() {
        return getRole(request.auth.uid) == 'customer' &&
               incomingData().customerId == request.auth.uid &&
               incomingData().status == 'upcoming'; // Customers can only create 'upcoming'
    }
    
    function isCreatingWalkInAsBarber() {
        return getRole(request.auth.uid) == 'barber' &&
               incomingData().barberId == request.auth.uid &&
               incomingData().customerId == null && // Walk-in
               incomingData().status == 'in-progress'; // Walk-ins start as 'in-progress'
    }

    function isBarberAcceptingBookings(barberId) {
      let barberDoc = get(/databases/$(database)/documents/users/$(barberId));
      return barberDoc.exists() && barberDoc.data.get('isAcceptingBookings', true) == true;
    }

    // Appointment Rules
    match /appointments/{appointmentId} {
      // READ: Any authenticated user can read appointment details.
      // This is necessary for customers to check barber availability.
      // Client-side logic should filter what is displayed to whom.
      allow read: if isSignedIn();

      allow create: if isSignedIn() &&
                       hasOnlyAllowedFieldsForCreate(incomingData()) &&
                       isValidAppointmentBaseDataForCreate(incomingData()) &&
                       areTimestampsValidForCreate(incomingData()) &&
                       (
                         (isCreatingOwnAppointmentAsCustomer() && isBarberAcceptingBookings(incomingData().barberId)) ||
                         isCreatingWalkInAsBarber()
                       );
                       // Complex validations like daily/weekly booking limits are resource-intensive for rules
                       // and are better handled by client-side checks + (optional) Cloud Functions for stricter enforcement.

      // UPDATE Rules
      // Customer checking in
      function canCustomerCheckIn(existing, incoming) {
        return getRole(request.auth.uid) == 'customer' && isAppointmentOwner(existing) &&
               existing.status == 'upcoming' && incoming.status == 'customer-initiated-check-in' &&
               incoming.customerCheckedInAt == request.time &&
               isFieldsChanged(['status', 'customerCheckedInAt', 'updatedAt']);
      }
      // Customer confirms barber's check-in (service starts)
      function canCustomerConfirmBarberCheckIn(existing, incoming) {
        return getRole(request.auth.uid) == 'customer' && isAppointmentOwner(existing) &&
               existing.status == 'barber-initiated-check-in' && incoming.status == 'in-progress' &&
               incoming.customerCheckedInAt == request.time && // Customer confirms now
               existing.barberCheckedInAt != null && // Barber must have checked in
               incoming.serviceActuallyStartedAt == request.time &&
               isFieldsChanged(['status', 'customerCheckedInAt', 'serviceActuallyStartedAt', 'updatedAt']);
      }
       // Customer marks service done
      function canCustomerMarkDone(existing, incoming) {
        return getRole(request.auth.uid) == 'customer' && isAppointmentOwner(existing) &&
               existing.status == 'in-progress' &&
               (incoming.status == 'customer-initiated-completion' || (incoming.status == 'completed' && existing.barberMarkedDoneAt != null)) &&
               incoming.customerMarkedDoneAt == request.time &&
               (incoming.status != 'completed' || incoming.serviceActuallyCompletedAt == request.time) &&
               isFieldsChanged(['status', 'customerMarkedDoneAt', 'serviceActuallyCompletedAt', 'updatedAt']);
      }
      // Customer confirms barber's completion
      function canCustomerConfirmBarberCompletion(existing, incoming) {
        return getRole(request.auth.uid) == 'customer' && isAppointmentOwner(existing) &&
               existing.status == 'barber-initiated-completion' && incoming.status == 'completed' &&
               incoming.customerMarkedDoneAt == request.time && // Customer confirms now
               existing.barberMarkedDoneAt != null && // Barber must have marked done
               incoming.serviceActuallyCompletedAt == request.time &&
               isFieldsChanged(['status', 'customerMarkedDoneAt', 'serviceActuallyCompletedAt', 'updatedAt']);
      }
      // Customer cancels an upcoming appointment
      function canCustomerCancel(existing, incoming) {
        return getRole(request.auth.uid) == 'customer' && isAppointmentOwner(existing) &&
               (existing.status == 'upcoming' || existing.status == 'customer-initiated-check-in' || existing.status == 'barber-initiated-check-in') &&
               incoming.status == 'cancelled' &&
               isFieldsChanged(['status', 'updatedAt']);
      }

      // Barber records customer arrival
      function canBarberCheckIn(existing, incoming) {
        return getRole(request.auth.uid) == 'barber' && isBarberOfAppointment(existing) &&
               existing.status == 'upcoming' && incoming.status == 'barber-initiated-check-in' &&
               incoming.barberCheckedInAt == request.time &&
               isFieldsChanged(['status', 'barberCheckedInAt', 'updatedAt']);
      }
      // Barber confirms customer's check-in (service starts)
      function canBarberConfirmCustomerCheckIn(existing, incoming) {
        return getRole(request.auth.uid) == 'barber' && isBarberOfAppointment(existing) &&
               existing.status == 'customer-initiated-check-in' && incoming.status == 'in-progress' &&
               incoming.barberCheckedInAt == request.time && // Barber confirms now
               existing.customerCheckedInAt != null && // Customer must have checked in
               incoming.serviceActuallyStartedAt == request.time &&
               isFieldsChanged(['status', 'barberCheckedInAt', 'serviceActuallyStartedAt', 'updatedAt']);
      }
      // Barber marks service done (can be for booked or walk-in)
      function canBarberMarkDone(existing, incoming) {
        return getRole(request.auth.uid) == 'barber' && isBarberOfAppointment(existing) &&
               existing.status == 'in-progress' &&
               (
                 // For booked appointments, moves to barber-initiated-completion or completed if customer also done
                 (existing.customerId != null && (incoming.status == 'barber-initiated-completion' || (incoming.status == 'completed' && existing.customerMarkedDoneAt != null))) ||
                 // For walk-ins (customerId is null), moves directly to completed
                 (existing.customerId == null && incoming.status == 'completed')
               ) &&
               incoming.barberMarkedDoneAt == request.time &&
               (incoming.status != 'completed' || incoming.serviceActuallyCompletedAt == request.time) &&
               isFieldsChanged(['status', 'barberMarkedDoneAt', 'serviceActuallyCompletedAt', 'updatedAt']);
      }
      // Barber confirms customer's completion
      function canBarberConfirmCustomerCompletion(existing, incoming) {
        return getRole(request.auth.uid) == 'barber' && isBarberOfAppointment(existing) &&
               existing.status == 'customer-initiated-completion' && incoming.status == 'completed' &&
               incoming.barberMarkedDoneAt == request.time && // Barber confirms now
               existing.customerMarkedDoneAt != null && // Customer must have marked done
               incoming.serviceActuallyCompletedAt == request.time &&
               isFieldsChanged(['status', 'barberMarkedDoneAt', 'serviceActuallyCompletedAt', 'updatedAt']);
      }

      allow update: if isSignedIn() && incomingData().updatedAt == request.time &&
                     // Ensure immutable fields are not changed
                     incomingData().id == existingData().id &&
                     incomingData().barberId == existingData().barberId &&
                     incomingData().customerId == existingData().customerId &&
                     incomingData().serviceId == existingData().serviceId &&
                     incomingData().price == existingData().price &&
                     incomingData().date == existingData().date &&
                     incomingData().startTime == existingData().startTime &&
                     incomingData().endTime == existingData().endTime &&
                     incomingData().createdAt == existingData().createdAt &&
                     // Allow specific state transitions
                     (
                       canCustomerCheckIn(existingData(), incomingData()) ||
                       canCustomerConfirmBarberCheckIn(existingData(), incomingData()) ||
                       canCustomerMarkDone(existingData(), incomingData()) ||
                       canCustomerConfirmBarberCompletion(existingData(), incomingData()) ||
                       canCustomerCancel(existingData(), incomingData()) ||
                       canBarberCheckIn(existingData(), incomingData()) ||
                       canBarberConfirmCustomerCheckIn(existingData(), incomingData()) ||
                       canBarberMarkDone(existingData(), incomingData()) ||
                       canBarberConfirmCustomerCompletion(existingData(), incomingData())
                     );

      // No general delete for appointments by users; use 'cancelled' status.
      allow delete: if false;
    }
  }
}

    
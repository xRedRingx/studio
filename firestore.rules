
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isUser(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function isRole(role) {
      return isAuthenticated() && request.auth.token.role == role;
    }

    function isBarber() {
      return isRole('barber');
    }

    function isCustomer() {
      return isRole('customer');
    }

    function getRole() {
      return request.auth.token.role;
    }

    function incomingData() {
      return request.resource.data;
    }

    function existingData() {
      return resource.data;
    }

    // User Profile Rules
    match /users/{userId} {
      allow read: if isAuthenticated(); // Any authenticated user can read any profile (e.g., for barber listings)
      allow create: if request.auth.uid == userId && // User can create their own profile document
                       incomingData().uid == userId &&
                       (incomingData().role == 'customer' || incomingData().role == 'barber') &&
                       incomingData().email == request.auth.token.email &&
                       incomingData().firstName is string && incomingData().firstName.size() > 0 &&
                       incomingData().lastName is string && incomingData().lastName.size() > 0 &&
                       (incomingData().phoneNumber == null || (incomingData().phoneNumber is string && incomingData().phoneNumber.matches('^\\+[1-9]\\d{1,14}$|^$'))) &&
                       (incomingData().address == null || (incomingData().address is string && incomingData().address.size() <= 100)) &&
                       (!('isAcceptingBookings' in incomingData()) || incomingData().isAcceptingBookings is bool) && // if present, must be bool
                       incomingData().createdAt == request.time && // Server timestamp on create
                       incomingData().updatedAt == request.time;  // Server timestamp on create

      allow update: if isUser(userId) && // User can update their own profile
                       incomingData().uid == existingData().uid && // Cannot change UID
                       incomingData().email == existingData().email && // Cannot change email via this update
                       incomingData().role == existingData().role && // Cannot change role
                       incomingData().createdAt == existingData().createdAt && // Cannot change creation date
                       incomingData().updatedAt == request.time && // Must set updatedAt to server time
                       incomingData().firstName is string && incomingData().firstName.size() > 0 &&
                       incomingData().lastName is string && incomingData().lastName.size() > 0 &&
                       (incomingData().phoneNumber == null || (incomingData().phoneNumber is string && incomingData().phoneNumber.matches('^\\+[1-9]\\d{1,14}$|^$'))) &&
                       (incomingData().address == null || (incomingData().address is string && incomingData().address.size() <= 100)) &&
                       (!('isAcceptingBookings' in incomingData()) || incomingData().isAcceptingBookings is bool) && // if present, must be bool
                       // Check allowed fields for update (preventing role, email, uid, createdAt change)
                       incomingData().keys().hasOnly(['uid', 'role', 'firstName', 'lastName', 'email', 'phoneNumber', 'address', 'isAcceptingBookings', 'fcmToken', 'createdAt', 'updatedAt', 'displayName', 'emailVerified']);
    }

    // Appointment Rules
    function isAppointmentOwner() {
      // For reads, either customer or barber of the appointment
      return request.auth.uid == resource.data.customerId || request.auth.uid == resource.data.barberId;
    }

    function isAppointmentParticipantForWrite() {
      // For writes, either customer or barber of the appointment based on incoming data
      return request.auth.uid == request.resource.data.customerId || request.auth.uid == request.resource.data.barberId;
    }

    function isCreatingOwnAppointmentAsCustomer() {
      return request.auth.uid == request.resource.data.customerId && isCustomer();
    }

    function isCreatingWalkInAsBarber() {
      return request.auth.uid == request.resource.data.barberId && isBarber() && request.resource.data.customerId == null;
    }

    // Helper: Validates base fields for an appointment on create
    function isValidAppointmentBaseDataForCreate(data) {
      return data.barberId is string &&
             data.barberName is string &&
             (data.customerId is string || data.customerId == null) && // customerId can be null for walk-ins
             data.customerName is string &&
             data.serviceId is string &&
             data.serviceName is string &&
             data.price is number && data.price >= 0 &&
             data.date is string && data.date.matches('^\\d{4}-\\d{2}-\\d{2}$') &&
             data.startTime is string && data.startTime.matches('^(0[1-9]|1[0-2]):[0-5][0-9] (AM|PM)$') &&
             data.endTime is string && data.endTime.matches('^(0[1-9]|1[0-2]):[0-5][0-9] (AM|PM)$') &&
             (data.status == 'upcoming' || (data.status == 'in-progress' && data.customerId == null)); // Walk-ins start as 'in-progress'
    }

    // Helper: Validates timestamp fields for creation
    function areTimestampsValidForCreate(data) {
      let isWalkIn = data.customerId == null;
      return data.createdAt is timestamp &&
             data.updatedAt is timestamp &&
             data.createdAt == data.updatedAt && // On create, these must be equal client-provided timestamps
             (isWalkIn ? (
                data.customerCheckedInAt is timestamp && data.customerCheckedInAt == data.createdAt &&
                data.barberCheckedInAt is timestamp && data.barberCheckedInAt == data.createdAt &&
                data.serviceActuallyStartedAt is timestamp && data.serviceActuallyStartedAt == data.createdAt
             ) : (
                data.customerCheckedInAt == null &&
                data.barberCheckedInAt == null &&
                data.serviceActuallyStartedAt == null
             )) &&
             data.customerMarkedDoneAt == null &&
             data.barberMarkedDoneAt == null &&
             data.serviceActuallyCompletedAt == null;
    }

    // Helper: Ensures only allowed fields are present on create
    function hasOnlyAllowedFieldsForCreate(data) {
      let allowedFields = [
        'barberId', 'barberName', 'customerId', 'customerName',
        'serviceId', 'serviceName', 'price', 'date', 'startTime', 'endTime',
        'status', 'createdAt', 'updatedAt',
        'customerCheckedInAt', 'barberCheckedInAt', 'serviceActuallyStartedAt',
        'customerMarkedDoneAt', 'barberMarkedDoneAt', 'serviceActuallyCompletedAt'
      ];
      return data.keys().hasOnly(allowedFields);
    }

    // Validates fields that should not change after creation
    function coreAppointmentFieldsUnchanged(incoming, existing) {
      return incoming.barberId == existing.barberId &&
             incoming.barberName == existing.barberName &&
             incoming.customerId == existing.customerId &&
             incoming.customerName == existing.customerName &&
             incoming.serviceId == existing.serviceId &&
             incoming.serviceName == existing.serviceName &&
             incoming.price == existing.price &&
             incoming.date == existing.date &&
             incoming.startTime == existing.startTime &&
             incoming.endTime == existing.endTime &&
             incoming.createdAt == existing.createdAt; // createdAt is immutable
    }

    // Rules for appointment status transitions and who can make them.
    function isValidAppointmentUpdate(data, existingData) {
      let newStatus = data.status;
      let oldStatus = existingData.status;
      let userRole = getRole();
      let userId = request.auth.uid;

      // Only specific fields can be updated, and `updatedAt` must change.
      if (data.updatedAt == existingData.updatedAt || !(data.updatedAt is timestamp)) return false;
      if (!coreAppointmentFieldsUnchanged(data, existingData)) return false;

      // Validate status transitions
      if (newStatus == 'customer-initiated-check-in') {
        return oldStatus == 'upcoming' && userRole == 'customer' && userId == existingData.customerId &&
               data.customerCheckedInAt is timestamp && data.customerCheckedInAt >= existingData.updatedAt && // Ensure new timestamp
               data.barberCheckedInAt == existingData.barberCheckedInAt && // Other timestamps unchanged
               data.serviceActuallyStartedAt == existingData.serviceActuallyStartedAt &&
               data.customerMarkedDoneAt == existingData.customerMarkedDoneAt &&
               data.barberMarkedDoneAt == existingData.barberMarkedDoneAt &&
               data.serviceActuallyCompletedAt == existingData.serviceActuallyCompletedAt;
      }
      if (newStatus == 'barber-initiated-check-in') {
        return oldStatus == 'upcoming' && userRole == 'barber' && userId == existingData.barberId &&
               data.barberCheckedInAt is timestamp && data.barberCheckedInAt >= existingData.updatedAt &&
               data.customerCheckedInAt == existingData.customerCheckedInAt && // Other timestamps unchanged
               data.serviceActuallyStartedAt == existingData.serviceActuallyStartedAt &&
               data.customerMarkedDoneAt == existingData.customerMarkedDoneAt &&
               data.barberMarkedDoneAt == existingData.barberMarkedDoneAt &&
               data.serviceActuallyCompletedAt == existingData.serviceActuallyCompletedAt;
      }
      if (newStatus == 'in-progress') {
        return (
          (oldStatus == 'customer-initiated-check-in' && userRole == 'barber' && userId == existingData.barberId && data.barberCheckedInAt is timestamp && data.barberCheckedInAt >= existingData.updatedAt && data.customerCheckedInAt == existingData.customerCheckedInAt) ||
          (oldStatus == 'barber-initiated-check-in' && userRole == 'customer' && userId == existingData.customerId && data.customerCheckedInAt is timestamp && data.customerCheckedInAt >= existingData.updatedAt && data.barberCheckedInAt == existingData.barberCheckedInAt) ||
          (oldStatus == 'barber-initiated-check-in' && userRole == 'barber' && userId == existingData.barberId && existingData.customerId == null) // Barber starting a walk-in directly
        ) && data.serviceActuallyStartedAt is timestamp && data.serviceActuallyStartedAt >= (data.barberCheckedInAt > data.customerCheckedInAt ? data.barberCheckedInAt : data.customerCheckedInAt) && // service start must be after both checkins
             data.customerMarkedDoneAt == existingData.customerMarkedDoneAt &&
             data.barberMarkedDoneAt == existingData.barberMarkedDoneAt &&
             data.serviceActuallyCompletedAt == existingData.serviceActuallyCompletedAt;
      }
      if (newStatus == 'customer-initiated-completion') {
        return oldStatus == 'in-progress' && userRole == 'customer' && userId == existingData.customerId &&
               data.customerMarkedDoneAt is timestamp && data.customerMarkedDoneAt >= existingData.updatedAt &&
               // other timestamps unchanged or correctly set from 'in-progress'
               data.customerCheckedInAt == existingData.customerCheckedInAt &&
               data.barberCheckedInAt == existingData.barberCheckedInAt &&
               data.serviceActuallyStartedAt == existingData.serviceActuallyStartedAt &&
               data.barberMarkedDoneAt == existingData.barberMarkedDoneAt &&
               data.serviceActuallyCompletedAt == existingData.serviceActuallyCompletedAt;
      }
      if (newStatus == 'barber-initiated-completion') {
        return oldStatus == 'in-progress' && userRole == 'barber' && userId == existingData.barberId &&
               data.barberMarkedDoneAt is timestamp && data.barberMarkedDoneAt >= existingData.updatedAt &&
               // other timestamps unchanged or correctly set from 'in-progress'
               data.customerCheckedInAt == existingData.customerCheckedInAt &&
               data.barberCheckedInAt == existingData.barberCheckedInAt &&
               data.serviceActuallyStartedAt == existingData.serviceActuallyStartedAt &&
               data.customerMarkedDoneAt == existingData.customerMarkedDoneAt &&
               data.serviceActuallyCompletedAt == existingData.serviceActuallyCompletedAt;
      }
      if (newStatus == 'completed') {
        return (
          (oldStatus == 'customer-initiated-completion' && userRole == 'barber' && userId == existingData.barberId && data.barberMarkedDoneAt is timestamp && data.barberMarkedDoneAt >= existingData.updatedAt && data.customerMarkedDoneAt == existingData.customerMarkedDoneAt) ||
          (oldStatus == 'barber-initiated-completion' && userRole == 'customer' && userId == existingData.customerId && data.customerMarkedDoneAt is timestamp && data.customerMarkedDoneAt >= existingData.updatedAt && data.barberMarkedDoneAt == existingData.barberMarkedDoneAt) ||
          (oldStatus == 'barber-initiated-completion' && userRole == 'barber' && userId == existingData.barberId && existingData.customerId == null) // Barber completing a walk-in
        ) && data.serviceActuallyCompletedAt is timestamp && data.serviceActuallyCompletedAt >= (data.barberMarkedDoneAt > data.customerMarkedDoneAt ? data.barberMarkedDoneAt : data.customerMarkedDoneAt) && // service completion must be after both marks
             // check-in timestamps must exist
             data.customerCheckedInAt == existingData.customerCheckedInAt &&
             data.barberCheckedInAt == existingData.barberCheckedInAt &&
             data.serviceActuallyStartedAt == existingData.serviceActuallyStartedAt;
      }
      if (newStatus == 'cancelled') {
        // Customer can cancel 'upcoming', 'customer-initiated-check-in', 'barber-initiated-check-in'
        // Barber can cancel any non-completed/non-cancelled state
        return (
          (userRole == 'customer' && userId == existingData.customerId && (oldStatus == 'upcoming' || oldStatus == 'customer-initiated-check-in' || oldStatus == 'barber-initiated-check-in')) ||
          (userRole == 'barber' && userId == existingData.barberId && oldStatus != 'completed' && oldStatus != 'cancelled')
        ) &&
        // Ensure only status and updatedAt are changed for cancellation
        data.keys().hasOnly(['status', 'updatedAt'] + existingData.keys()); // Allows only status and updatedAt to change from existing fields
      }
      return false; // No other transitions allowed
    }


    match /appointments/{appointmentId} {
      allow read: if isAuthenticated() && isAppointmentOwner();

      allow create: if isAuthenticated() &&
                       (isCreatingOwnAppointmentAsCustomer() || isCreatingWalkInAsBarber()) &&
                       isValidAppointmentBaseDataForCreate(incomingData()) &&
                       areTimestampsValidForCreate(incomingData()) &&
                       hasOnlyAllowedFieldsForCreate(incomingData()) &&
                       // For customer booking, check if barber is accepting bookings.
                       // Use .get(field, defaultValue) to handle missing field gracefully.
                       (isCreatingWalkInAsBarber() || get(/databases/$(database)/documents/users/$(incomingData().barberId)).data.get('isAcceptingBookings', true) == true);
                       // Daily/Weekly limits are primarily handled client-side.
                       // Server-side checks for this were removed due to complexity/unreliability in rules alone.

      allow update: if isAuthenticated() &&
                       isAppointmentParticipantForWrite() && // Ensure user is part of appointment
                       isValidAppointmentUpdate(incomingData(), existingData());

      allow delete: if false; // No one can delete appointments directly, use 'cancelled' status.
    }

    // Barber Schedule Rules
    match /barberSchedules/{barberId} {
      allow read: if isAuthenticated(); // All authenticated users can read schedules (e.g., for booking)
      allow create: if isBarber() && request.auth.uid == barberId && // Barber can create their own schedule
                       incomingData().barberId == barberId &&
                       incomingData().schedule is list &&
                       incomingData().updatedAt == request.time;
      allow update: if isBarber() && request.auth.uid == barberId && // Barber can update their own schedule
                       incomingData().barberId == existingData().barberId &&
                       incomingData().schedule is list &&
                       incomingData().updatedAt == request.time;

      match /unavailableDates/{dateId} {
        allow read: if isAuthenticated(); // All authenticated users can read unavailable dates
        allow create: if isBarber() && request.auth.uid == barberId && // Barber creating for themselves
                         incomingData().barberId == barberId &&
                         incomingData().date == dateId && // dateId is YYYY-MM-DD
                         incomingData().date.matches('^\\d{4}-\\d{2}-\\d{2}$') &&
                         (!('reason' in incomingData()) || incomingData().reason is string) &&
                         incomingData().createdAt == request.time;
        allow delete: if isBarber() && request.auth.uid == barberId; // Barber can delete their own unavailable dates
      }
    }

    // Barber Services Rules
    match /services/{serviceId} {
      allow read: if true; // All users can read services
      allow create: if isBarber() && // Only barbers can create services
                       incomingData().barberId == request.auth.uid && // Barber ID matches authenticated user
                       incomingData().name is string && incomingData().name.size() > 0 &&
                       incomingData().price is number && incomingData().price >= 0 &&
                       incomingData().duration is number && incomingData().duration > 0 &&
                       incomingData().createdAt == request.time &&
                       incomingData().updatedAt == request.time;
      allow update: if isBarber() && // Only barbers can update
                       existingData().barberId == request.auth.uid && // Can only update their own service
                       incomingData().barberId == existingData().barberId && // Barber ID cannot change
                       incomingData().name is string && incomingData().name.size() > 0 &&
                       incomingData().price is number && incomingData().price >= 0 &&
                       incomingData().duration is number && incomingData().duration > 0 &&
                       incomingData().createdAt == existingData().createdAt && // Cannot change creation date
                       incomingData().updatedAt == request.time;
      allow delete: if isBarber() && existingData().barberId == request.auth.uid; // Barber can delete their own service
    }
  }
}

    
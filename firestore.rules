
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isUser(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function getUserRole(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data.role;
    }

    function isBarber(userId) {
      return isAuthenticated() && getUserRole(userId) == 'barber';
    }

    function isCustomer(userId) {
      return isAuthenticated() && getUserRole(userId) == 'customer';
    }

    function isBarberAcceptingBookings(barberUserId) {
      let barberDoc = get(/databases/$(database)/documents/users/$(barberUserId)).data;
      // Default to true if the field is not set or is explicitly true
      return barberDoc.isAcceptingBookings == null || barberDoc.isAcceptingBookings == true;
    }

    // Limit bookings per day
    function hasMaxBookingsPerDay(customerId, dateString) {
      // Firestore queries in rules are limited. This checks for >= 1 existing booking.
      // For more complex limits (e.g., >1), you'd need backend logic or more complex rule structures.
      return TAMPgetAfter(/databases/$(database)/documents/appointments,
                  [['customerId', '==', customerId], ['date', '==', dateString], ['status', '!=', 'cancelled']],
                  [] // No ordering needed, just existence check
                ).size() >= 1;
    }

    // Limit bookings per week (simplified: checks for >= 2 in a 7-day string range)
    // This is a simplification. True weekly logic based on week boundaries is complex for rules.
    // Assumes dateString is YYYY-MM-DD.
    // A robust weekly limit is better handled by backend/cloud functions.
    function hasMaxBookingsPerWeek(customerId, dateString) {
      // This is a placeholder for a more complex weekly check.
      // For simplicity, let's assume 2 bookings in total across all time for now,
      // or make it less restrictive if too complex.
      // A true weekly check needs to calculate week boundaries which is hard in rules.
      // Let's limit total active bookings to a small number as a proxy.
      return TAMPgetAfter(/databases/$(database)/documents/appointments,
                  [['customerId', '==', customerId], ['status', 'in', ['upcoming', 'customer-initiated-check-in', 'barber-initiated-check-in', 'in-progress']]],
                  []
                ).size() >= 2; // Max 2 active bookings overall for a customer
    }

    function isValidStatus(status) {
      return status in ['upcoming', 'customer-initiated-check-in', 'barber-initiated-check-in', 'in-progress', 'customer-initiated-completion', 'barber-initiated-completion', 'completed', 'cancelled'];
    }

    // Validates common appointment fields for create and update
    function isValidAppointmentData(newData, oldData) {
      let commonValidations =
        newData.barberId is string && newData.barberId.size() > 0 &&
        newData.barberName is string && newData.barberName.size() > 0 &&
        newData.serviceId is string && newData.serviceId.size() > 0 &&
        newData.serviceName is string && newData.serviceName.size() > 0 &&
        newData.price is number && newData.price >= 0 &&
        newData.date is string && newData.date.matches('^\\d{4}-\\d{2}-\\d{2}$') &&
        newData.startTime is string && newData.startTime.matches('^(0[1-9]|1[0-2]):[0-5][0-9] (AM|PM)$') &&
        newData.endTime is string && newData.endTime.matches('^(0[1-9]|1[0-2]):[0-5][0-9] (AM|PM)$') &&
        newData.status is string && isValidStatus(newData.status) &&
        (newData.customerId == null || (newData.customerId is string && newData.customerId.size() > 0)) &&
        newData.customerName is string && newData.customerName.size() > 0 &&
        // Timestamps can be null or actual timestamps
        (newData.customerCheckedInAt == null || newData.customerCheckedInAt is timestamp) &&
        (newData.barberCheckedInAt == null || newData.barberCheckedInAt is timestamp) &&
        (newData.serviceActuallyStartedAt == null || newData.serviceActuallyStartedAt is timestamp) &&
        (newData.customerMarkedDoneAt == null || newData.customerMarkedDoneAt is timestamp) &&
        (newData.barberMarkedDoneAt == null || newData.barberMarkedDoneAt is timestamp) &&
        (newData.serviceActuallyCompletedAt == null || newData.serviceActuallyCompletedAt is timestamp) &&
        newData.createdAt is timestamp &&
        newData.updatedAt is timestamp && newData.updatedAt >= newData.createdAt;

      if (oldData == null) { // Create
        return commonValidations &&
               newData.status == 'upcoming' && // Initial status on create by customer
               newData.customerId == request.auth.uid && // Customer ID must match current user
               // Ensure all action timestamps are null on creation by customer
               newData.customerCheckedInAt == null &&
               newData.barberCheckedInAt == null &&
               newData.serviceActuallyStartedAt == null &&
               newData.customerMarkedDoneAt == null &&
               newData.barberMarkedDoneAt == null &&
               newData.serviceActuallyCompletedAt == null &&
               newData.updatedAt == newData.createdAt; // On create, updatedAt must be same as createdAt
      }
      // For update, more specific checks are in main update rule
      return commonValidations;
    }

    function isAppointmentFieldUnchanged(fieldName, newData, oldData) {
      return newData[fieldName] == oldData[fieldName];
    }


    // User Profiles
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow create: if request.auth.uid == userId &&
                       request.resource.data.uid == userId &&
                       request.resource.data.email == request.auth.token.email &&
                       (request.resource.data.role == 'customer' || request.resource.data.role == 'barber') &&
                       request.resource.data.firstName is string && request.resource.data.firstName.size() > 0 &&
                       request.resource.data.lastName is string && request.resource.data.lastName.size() > 0 &&
                       (request.resource.data.phoneNumber == null || request.resource.data.phoneNumber is string) &&
                       (request.resource.data.address == null || request.resource.data.address is string) &&
                       (request.resource.data.role == 'customer' || request.resource.data.isAcceptingBookings is bool) &&
                       request.resource.data.fcmToken == null &&
                       request.resource.data.createdAt == request.time && // Server sets this
                       request.resource.data.updatedAt == request.time;  // Server sets this

      allow update: if isUser(userId) &&
                       request.resource.data.uid == userId && // Cannot change uid
                       request.resource.data.email == resource.data.email && // Cannot change email
                       request.resource.data.role == resource.data.role && // Cannot change role
                       request.resource.data.createdAt == resource.data.createdAt && // Cannot change createdAt
                       request.resource.data.updatedAt == request.time && // Server sets this
                       // Allow updating specific fields:
                       request.resource.data.firstName is string &&
                       request.resource.data.lastName is string &&
                       (request.resource.data.phoneNumber == null || request.resource.data.phoneNumber is string) &&
                       (request.resource.data.address == null || request.resource.data.address is string) &&
                       // isAcceptingBookings for barbers
                       (resource.data.role == 'customer' || request.resource.data.isAcceptingBookings is bool) &&
                       // fcmToken
                       (request.resource.data.fcmToken == null || request.resource.data.fcmToken is string);
    }

    // Barber Services
    match /services/{serviceId} {
      allow read: if true; // Services are public
      allow create: if isBarber(request.resource.data.barberId) &&
                       request.resource.data.barberId == request.auth.uid &&
                       request.resource.data.name is string && request.resource.data.name.size() > 0 &&
                       request.resource.data.price is number && request.resource.data.price >= 0 &&
                       request.resource.data.duration is number && request.resource.data.duration > 0 &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time;
      allow update: if isBarber(resource.data.barberId) &&
                       resource.data.barberId == request.auth.uid &&
                       request.resource.data.barberId == resource.data.barberId && // barberId cannot change
                       request.resource.data.name is string && request.resource.data.name.size() > 0 &&
                       request.resource.data.price is number && request.resource.data.price >= 0 &&
                       request.resource.data.duration is number && request.resource.data.duration > 0 &&
                       request.resource.data.createdAt == resource.data.createdAt && // createdAt cannot change
                       request.resource.data.updatedAt == request.time;
      allow delete: if isBarber(resource.data.barberId) && resource.data.barberId == request.auth.uid;
    }

    // Barber Schedules (Availability and Unavailable Dates)
    match /barberSchedules/{barberId} {
      allow read: if isAuthenticated(); // Customers need to read for booking, barbers for dashboard
      allow create, update: if isUser(barberId) && isBarber(barberId) &&
                               request.resource.data.barberId == barberId &&
                               request.resource.data.schedule is list &&
                               request.resource.data.updatedAt == request.time;
      // No delete for the main schedule document, only update or clear its contents.

      match /unavailableDates/{dateId} {
        allow read: if isAuthenticated();
        allow create: if isUser(barberId) && isBarber(barberId) &&
                         request.resource.data.barberId == barberId &&
                         request.resource.data.date == dateId && // Ensure ID matches date
                         request.resource.data.date is string && request.resource.data.date.matches('^\\d{4}-\\d{2}-\\d{2}$') &&
                         (request.resource.data.reason == null || request.resource.data.reason is string) &&
                         request.resource.data.createdAt == request.time;
        allow delete: if isUser(barberId) && isBarber(barberId);
        // No update for unavailable dates, delete and re-create if reason changes.
      }
    }

    // Appointments
    match /appointments/{appointmentId} {
      allow create: if isAuthenticated() &&
                       // Customer creating for themselves
                       getUserRole(request.auth.uid) == 'customer' &&
                       request.resource.data.customerId == request.auth.uid &&
                       // Barber related checks
                       request.resource.data.barberId is string && request.resource.data.barberId.size() > 0 &&
                       isBarberAcceptingBookings(request.resource.data.barberId) &&
                       // Booking limit checks
                       !hasMaxBookingsPerDay(request.auth.uid, request.resource.data.date) &&
                       !hasMaxBookingsPerWeek(request.auth.uid, request.resource.data.date) &&
                       // Data integrity for create
                       isValidAppointmentData(request.resource.data, null) && // null for oldData on create
                       request.resource.data.status == 'upcoming' &&
                       request.resource.data.customerCheckedInAt == null &&
                       request.resource.data.barberCheckedInAt == null &&
                       request.resource.data.serviceActuallyStartedAt == null &&
                       request.resource.data.customerMarkedDoneAt == null &&
                       request.resource.data.barberMarkedDoneAt == null &&
                       request.resource.data.serviceActuallyCompletedAt == null &&
                       // Timestamps: Client sends Timestamp.now(), ensure they are valid and consistent
                       request.resource.data.createdAt is timestamp &&
                       request.resource.data.updatedAt is timestamp &&
                       request.resource.data.updatedAt == request.resource.data.createdAt;

      allow read: if isAuthenticated() &&
                     (request.auth.uid == resource.data.customerId || request.auth.uid == resource.data.barberId);

      allow update: if isAuthenticated() &&
                       // Ensure essential fields are not changed by client updates once set
                       isAppointmentFieldUnchanged('barberId', request.resource.data, resource.data) &&
                       isAppointmentFieldUnchanged('barberName', request.resource.data, resource.data) &&
                       isAppointmentFieldUnchanged('customerId', request.resource.data, resource.data) &&
                       isAppointmentFieldUnchanged('customerName', request.resource.data, resource.data) &&
                       isAppointmentFieldUnchanged('serviceId', request.resource.data, resource.data) &&
                       isAppointmentFieldUnchanged('serviceName', request.resource.data, resource.data) &&
                       isAppointmentFieldUnchanged('price', request.resource.data, resource.data) &&
                       isAppointmentFieldUnchanged('date', request.resource.data, resource.data) &&
                       isAppointmentFieldUnchanged('startTime', request.resource.data, resource.data) &&
                       isAppointmentFieldUnchanged('endTime', request.resource.data, resource.data) &&
                       isAppointmentFieldUnchanged('createdAt', request.resource.data, resource.data) &&
                       request.resource.data.updatedAt == request.time && // Server sets updatedAt
                       isValidAppointmentData(request.resource.data, resource.data) && // Basic data integrity
                       (
                         // Case 1: Customer actions
                         (isCustomer(request.auth.uid) && request.auth.uid == resource.data.customerId &&
                           (
                             // Customer checks in (from 'upcoming')
                             (resource.data.status == 'upcoming' && request.resource.data.status == 'customer-initiated-check-in' &&
                               request.resource.data.customerCheckedInAt == request.time &&
                               isAppointmentFieldUnchanged('barberCheckedInAt', request.resource.data, resource.data) &&
                               isAppointmentFieldUnchanged('serviceActuallyStartedAt', request.resource.data, resource.data)
                             ) ||
                             // Customer confirms barber's check-in (from 'barber-initiated-check-in')
                             (resource.data.status == 'barber-initiated-check-in' && request.resource.data.status == 'in-progress' &&
                               resource.data.barberCheckedInAt != null && // Barber must have checked in first
                               request.resource.data.customerCheckedInAt == request.time &&
                               request.resource.data.serviceActuallyStartedAt == request.time &&
                               isAppointmentFieldUnchanged('barberCheckedInAt', request.resource.data, resource.data) // Ensure barberCheckedInAt is not cleared by customer
                             ) ||
                             // Customer marks done (from 'in-progress')
                             (resource.data.status == 'in-progress' && request.resource.data.status == 'customer-initiated-completion' &&
                               request.resource.data.customerMarkedDoneAt == request.time &&
                               isAppointmentFieldUnchanged('barberMarkedDoneAt', request.resource.data, resource.data) &&
                               isAppointmentFieldUnchanged('serviceActuallyCompletedAt', request.resource.data, resource.data)
                             ) ||
                             // Customer confirms barber's completion (from 'barber-initiated-completion')
                             (resource.data.status == 'barber-initiated-completion' && request.resource.data.status == 'completed' &&
                               resource.data.barberMarkedDoneAt != null && // Barber must have marked done first
                               request.resource.data.customerMarkedDoneAt == request.time &&
                               request.resource.data.serviceActuallyCompletedAt == request.time &&
                               isAppointmentFieldUnchanged('barberMarkedDoneAt', request.resource.data, resource.data) // Ensure barberMarkedDoneAt is not cleared
                             ) ||
                             // Customer cancels (from 'upcoming', 'customer-initiated-check-in', 'barber-initiated-check-in')
                             (
                               (resource.data.status == 'upcoming' || resource.data.status == 'customer-initiated-check-in' || resource.data.status == 'barber-initiated-check-in') &&
                               request.resource.data.status == 'cancelled'
                             )
                           )
                         ) ||
                         // Case 2: Barber actions
                         (isBarber(request.auth.uid) && request.auth.uid == resource.data.barberId &&
                           (
                             // Barber records customer arrival / walk-in check-in (from 'upcoming')
                             (resource.data.status == 'upcoming' && request.resource.data.status == 'barber-initiated-check-in' &&
                               request.resource.data.barberCheckedInAt == request.time &&
                               isAppointmentFieldUnchanged('customerCheckedInAt', request.resource.data, resource.data) &&
                               isAppointmentFieldUnchanged('serviceActuallyStartedAt', request.resource.data, resource.data)
                             ) ||
                             // Barber confirms customer's check-in / starts service (from 'customer-initiated-check-in')
                             (resource.data.status == 'customer-initiated-check-in' && request.resource.data.status == 'in-progress' &&
                               resource.data.customerCheckedInAt != null && // Customer must have checked in first
                               request.resource.data.barberCheckedInAt == request.time &&
                               request.resource.data.serviceActuallyStartedAt == request.time &&
                               isAppointmentFieldUnchanged('customerCheckedInAt', request.resource.data, resource.data) // Ensure customerCheckedInAt is not cleared
                             ) ||
                             // Barber starts walk-in (customerId is null, from 'barber-initiated-check-in' or directly to 'in-progress' on create)
                             // Walk-ins are created by barber with 'in-progress' directly. This covers if it was somehow 'barber-initiated-check-in'.
                             (resource.data.customerId == null && resource.data.status == 'barber-initiated-check-in' && request.resource.data.status == 'in-progress' &&
                               request.resource.data.serviceActuallyStartedAt == request.time
                             ) ||
                             // Barber marks done (from 'in-progress')
                             (resource.data.status == 'in-progress' && request.resource.data.status == 'barber-initiated-completion' &&
                               request.resource.data.barberMarkedDoneAt == request.time &&
                               isAppointmentFieldUnchanged('customerMarkedDoneAt', request.resource.data, resource.data) &&
                               isAppointmentFieldUnchanged('serviceActuallyCompletedAt', request.resource.data, resource.data)
                             ) ||
                             // Barber confirms customer's completion (from 'customer-initiated-completion')
                             (resource.data.status == 'customer-initiated-completion' && request.resource.data.status == 'completed' &&
                               resource.data.customerMarkedDoneAt != null && // Customer must have marked done first
                               request.resource.data.barberMarkedDoneAt == request.time &&
                               request.resource.data.serviceActuallyCompletedAt == request.time &&
                               isAppointmentFieldUnchanged('customerMarkedDoneAt', request.resource.data, resource.data) // Ensure customerMarkedDoneAt is not cleared
                             ) ||
                             // Barber marks walk-in as complete (from 'in-progress', customerId is null)
                             (resource.data.customerId == null && resource.data.status == 'in-progress' && request.resource.data.status == 'completed' &&
                               request.resource.data.barberMarkedDoneAt == request.time &&
                               request.resource.data.serviceActuallyCompletedAt == request.time
                             )
                           )
                         )
                       );
      // No direct delete of appointments by clients to maintain history. Mark as 'cancelled'.
      // Deletion could be an admin/server-side function if absolutely needed.
      allow delete: if false;
    }
  }
}

    
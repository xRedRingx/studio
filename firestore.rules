
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper to get user data from the 'users' collection
    function getUserData(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    // Helper to check if a user is signed in
    function isSignedIn() {
      return request.auth != null;
    }

    // Helper to check if the signed-in user is the user specified by userId
    function isUser(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Helper to get the role of the currently signed-in user
    function userRole() {
      // Ensure request.auth is not null before trying to access uid
      if (request.auth == null) {
        return null;
      }
      return getUserData(request.auth.uid).role;
    }

    // Helper to check if the signed-in user is a barber
    function isBarber() {
      return isSignedIn() && userRole() == 'barber';
    }

    // Helper to check if the signed-in user is a customer
    function isCustomer() {
      return isSignedIn() && userRole() == 'customer';
    }

    // Users collection
    match /users/{userId} {
      allow read: if isSignedIn() && (isUser(userId) || isBarber()); // Users can read their own profile, Barbers can read customer profiles for context.
      allow create: if request.auth.uid == userId && // User can only create their own document
                       request.resource.data.uid == userId &&
                       request.resource.data.email == request.auth.token.email &&
                       (request.resource.data.role == 'customer' || request.resource.data.role == 'barber') &&
                       request.resource.data.createdAt == request.time && // Ensure server timestamp for creation
                       request.resource.data.updatedAt == request.time;  // Ensure server timestamp for creation
      allow update: if isUser(userId) &&
                       // Prevent changing immutable fields
                       !( 'uid' in request.resource.data && request.resource.data.uid != resource.data.uid ) &&
                       !( 'email' in request.resource.data && request.resource.data.email != resource.data.email ) &&
                       !( 'role'in request.resource.data && request.resource.data.role != resource.data.role ) &&
                       !( 'createdAt' in request.resource.data && request.resource.data.createdAt != resource.data.createdAt) &&
                       request.resource.data.updatedAt == request.time; // Ensure server timestamp for updates
      allow delete: if false; // Prevent accidental deletion of user accounts
    }

    // Services collection
    match /services/{serviceId} {
      allow read: if true; // All users (signed in or not) can read services
      allow create: if isBarber() &&
                       request.resource.data.barberId == request.auth.uid &&
                       request.resource.data.name is string && request.resource.data.name != '' &&
                       request.resource.data.price is number && request.resource.data.price >= 0 &&
                       request.resource.data.duration is number && request.resource.data.duration > 0 &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time;
      allow update: if isBarber() &&
                       resource.data.barberId == request.auth.uid && // Only owning barber
                       request.resource.data.barberId == resource.data.barberId && // barberId cannot change
                       request.resource.data.name is string && request.resource.data.name != '' &&
                       request.resource.data.price is number && request.resource.data.price >= 0 &&
                       request.resource.data.duration is number && request.resource.data.duration > 0 &&
                       request.resource.data.createdAt == resource.data.createdAt && // createdAt cannot change
                       request.resource.data.updatedAt == request.time;
      allow delete: if isBarber() && resource.data.barberId == request.auth.uid;
    }

    // Barber Schedules collection
    match /barberSchedules/{barberId} {
      allow read: if isSignedIn(); // Any signed-in user can read schedules
      allow create, update: if isBarber() && barberId == request.auth.uid &&
                               request.resource.data.barberId == barberId &&
                               request.resource.data.schedule is list &&
                               // Basic check for schedule structure, assumes at least one entry or empty
                               (request.resource.data.schedule.size() == 0 || (
                                 request.resource.data.schedule[0].day is string &&
                                 request.resource.data.schedule[0].isOpen is bool &&
                                 request.resource.data.schedule[0].startTime is string &&
                                 request.resource.data.schedule[0].endTime is string
                               )) &&
                               request.resource.data.updatedAt == request.time;
      allow delete: if false; // Prevent deletion, manage through updates

      // Unavailable Dates subcollection
      match /unavailableDates/{dateId} {
        allow read: if isSignedIn();
        allow create: if isBarber() &&
                         request.resource.data.barberId == request.auth.uid && // Barber creating must be the one in the path
                         request.resource.data.date == dateId && // dateId (docId) must match date field
                         request.resource.data.date.matches('^[0-9]{4}-[0-9]{2}-[0-9]{2}$') &&
                         (request.resource.data.reason == null || request.resource.data.reason is string) &&
                         request.resource.data.createdAt == request.time;
        allow delete: if isBarber() && resource.data.barberId == request.auth.uid;
        allow update: if false; // No updates to unavailable dates, delete and re-create
      }
    }

    // Appointments collection
    match /appointments/{appointmentId} {

      // Helper function to validate common appointment data fields
      function isValidAppointmentBaseData(data) {
        return data.barberId is string && data.barberId != '' &&
               data.barberName is string && data.barberName != '' &&
               (data.customerId == null || (data.customerId is string && data.customerId != '')) &&
               data.customerName is string && data.customerName != '' &&
               data.serviceId is string && data.serviceId != '' &&
               data.serviceName is string && data.serviceName != '' &&
               data.price is number && data.price >= 0 &&
               data.date is string && data.date.matches('^[0-9]{4}-[0-9]{2}-[0-9]{2}$') &&
               data.startTime is string && data.startTime.matches('^(0[1-9]|1[0-2]):[0-5][0-9] (AM|PM)$') &&
               data.endTime is string && data.endTime.matches('^(0[1-9]|1[0-2]):[0-5][0-9] (AM|PM)$') &&
               data.status is string &&
               ['upcoming', 'customer-initiated-check-in', 'barber-initiated-check-in', 'in-progress', 'customer-initiated-completion', 'barber-initiated-completion', 'completed', 'cancelled'].hasAny([data.status]);
      }

      function areTimestampsValidForCreate(data) {
          return data.createdAt == request.time &&
                 data.updatedAt == request.time &&
                 data.customerCheckedInAt == null &&
                 data.barberCheckedInAt == null &&
                 data.serviceActuallyStartedAt == null &&
                 data.customerMarkedDoneAt == null &&
                 data.barberMarkedDoneAt == null &&
                 data.serviceActuallyCompletedAt == null;
      }

      function areTimestampsValidForWalkInCreate(data) {
          return data.createdAt == request.time &&
                 data.updatedAt == request.time &&
                 data.customerCheckedInAt == request.time && // Implicit
                 data.barberCheckedInAt == request.time &&   // Barber is checking in
                 data.serviceActuallyStartedAt == request.time && // Starts immediately
                 data.customerMarkedDoneAt == null &&
                 data.barberMarkedDoneAt == null &&
                 data.serviceActuallyCompletedAt == null;
      }
      
      function areNullableInteractionTimestampsValid(data) {
        // Checks if present, they are timestamps. Null is allowed.
        let fields = ['customerCheckedInAt', 'barberCheckedInAt', 'serviceActuallyStartedAt', 'customerMarkedDoneAt', 'barberMarkedDoneAt', 'serviceActuallyCompletedAt'];
        return fields.all(fieldName => data[fieldName] == null || data[fieldName] is timestamp);
      }


      // Helper to check if the user is the customer for this appointment
      function isCustomerForAppointment(appointmentData) {
        return isSignedIn() && userRole() == 'customer' && request.auth.uid == appointmentData.customerId;
      }

      // Helper to check if the user is the barber for this appointment
      function isBarberForAppointment(appointmentData) {
        return isSignedIn() && userRole() == 'barber' && request.auth.uid == appointmentData.barberId;
      }

      // Check if this is a walk-in appointment
      function isWalkIn(appointmentData) {
        return appointmentData.customerId == null;
      }

      // --- CREATE ---
      allow create: if isSignedIn() &&
                       isValidAppointmentBaseData(request.resource.data) &&
                       areNullableInteractionTimestampsValid(request.resource.data) &&
                       (
                         // Customer booking
                         (isCustomer() && request.resource.data.customerId == request.auth.uid &&
                          request.resource.data.status == 'upcoming' &&
                          areTimestampsValidForCreate(request.resource.data)
                         ) ||
                         // Barber creating walk-in
                         (isBarber() && request.resource.data.barberId == request.auth.uid &&
                          isWalkIn(request.resource.data) &&
                          request.resource.data.status == 'in-progress' &&
                          areTimestampsValidForWalkInCreate(request.resource.data)
                         )
                       );

      // --- READ ---
      allow read: if isSignedIn() &&
                     (isCustomerForAppointment(resource.data) || isBarberForAppointment(resource.data));

      // --- UPDATE ---
      function canTransitionStatus(currentStatus, nextStatus, isBarberAction, isCustomerAction, isWalkInAppointment) {
        if (currentStatus == 'upcoming') {
          return (isCustomerAction && nextStatus == 'customer-initiated-check-in') ||
                 (isBarberAction && nextStatus == 'barber-initiated-check-in') ||
                 (isCustomerAction && nextStatus == 'cancelled'); // Customer can cancel upcoming
        }
        if (currentStatus == 'customer-initiated-check-in') {
          return (isBarberAction && nextStatus == 'in-progress') ||
                 (isCustomerAction && nextStatus == 'cancelled'); // Customer can cancel if barber hasn't confirmed
        }
        if (currentStatus == 'barber-initiated-check-in') {
          if (isWalkInAppointment) {
            return isBarberAction && nextStatus == 'in-progress'; // Barber "starts" walk-in (if not already set at create)
          }
          return isCustomerAction && nextStatus == 'in-progress'; // Customer confirms
        }
        if (currentStatus == 'in-progress') {
          return (isCustomerAction && nextStatus == 'customer-initiated-completion') ||
                 (isBarberAction && nextStatus == 'barber-initiated-completion');
        }
        if (currentStatus == 'customer-initiated-completion') {
          return isBarberAction && nextStatus == 'completed';
        }
        if (currentStatus == 'barber-initiated-completion') {
          if (isWalkInAppointment) {
            return isBarberAction && nextStatus == 'completed'; // Barber completes walk-in
          }
          return isCustomerAction && nextStatus == 'completed';
        }
        return false; // No other transitions allowed by default
      }

      function areFieldsAllowedForUpdate(newData, oldData, currentStatus, nextStatus, isBarberAction, isCustomerAction, isWalkInAppointment) {
        // Core fields that should not change after creation
        if (newData.barberId != oldData.barberId ||
            newData.barberName != oldData.barberName ||
            newData.customerId != oldData.customerId || // customerId can't change post-creation
            newData.customerName != oldData.customerName || // customerName might change if profile updates, but not via appointment update
            newData.serviceId != oldData.serviceId ||
            newData.serviceName != oldData.serviceName ||
            newData.price != oldData.price ||
            newData.date != oldData.date ||
            newData.startTime != oldData.startTime ||
            newData.endTime != oldData.endTime ||
            newData.createdAt != oldData.createdAt) {
          return false;
        }

        // Status and updatedAt are expected to change
        if (newData.updatedAt != request.time) { return false; } // Must be server time

        // Check allowed timestamp changes based on status transition
        if (currentStatus == 'upcoming' && nextStatus == 'customer-initiated-check-in' && isCustomerAction) {
          return newData.customerCheckedInAt == request.time &&
                 oldData.customerCheckedInAt == null && // Ensure it was null before
                 newData.barberCheckedInAt == oldData.barberCheckedInAt &&
                 newData.serviceActuallyStartedAt == oldData.serviceActuallyStartedAt &&
                 newData.customerMarkedDoneAt == oldData.customerMarkedDoneAt &&
                 newData.barberMarkedDoneAt == oldData.barberMarkedDoneAt &&
                 newData.serviceActuallyCompletedAt == oldData.serviceActuallyCompletedAt;
        }
        if (currentStatus == 'upcoming' && nextStatus == 'barber-initiated-check-in' && isBarberAction) {
          return newData.barberCheckedInAt == request.time &&
                 oldData.barberCheckedInAt == null &&
                 newData.customerCheckedInAt == oldData.customerCheckedInAt &&
                 newData.serviceActuallyStartedAt == oldData.serviceActuallyStartedAt &&
                 newData.customerMarkedDoneAt == oldData.customerMarkedDoneAt &&
                 newData.barberMarkedDoneAt == oldData.barberMarkedDoneAt &&
                 newData.serviceActuallyCompletedAt == oldData.serviceActuallyCompletedAt;
        }
        if (currentStatus == 'customer-initiated-check-in' && nextStatus == 'in-progress' && isBarberAction) {
          return newData.barberCheckedInAt == request.time &&
                 newData.serviceActuallyStartedAt == request.time &&
                 oldData.barberCheckedInAt == null && oldData.serviceActuallyStartedAt == null && // Ensure they were null
                 newData.customerCheckedInAt == oldData.customerCheckedInAt; // Should exist
        }
        if (currentStatus == 'barber-initiated-check-in' && !isWalkInAppointment && nextStatus == 'in-progress' && isCustomerAction) {
          return newData.customerCheckedInAt == request.time &&
                 newData.serviceActuallyStartedAt == request.time &&
                 oldData.customerCheckedInAt == null && oldData.serviceActuallyStartedAt == null &&
                 newData.barberCheckedInAt == oldData.barberCheckedInAt; // Should exist
        }
        // Walk-in already 'in-progress' at creation usually. If barber needs to explicitly start:
        if (currentStatus == 'barber-initiated-check-in' && isWalkInAppointment && nextStatus == 'in-progress' && isBarberAction) {
            return newData.serviceActuallyStartedAt == request.time && oldData.serviceActuallyStartedAt == null;
        }

        if (currentStatus == 'in-progress' && nextStatus == 'customer-initiated-completion' && isCustomerAction) {
          return newData.customerMarkedDoneAt == request.time && oldData.customerMarkedDoneAt == null;
        }
        if (currentStatus == 'in-progress' && nextStatus == 'barber-initiated-completion' && isBarberAction) {
          return newData.barberMarkedDoneAt == request.time && oldData.barberMarkedDoneAt == null;
        }
        if (currentStatus == 'customer-initiated-completion' && nextStatus == 'completed' && isBarberAction) {
          return newData.barberMarkedDoneAt == request.time &&
                 newData.serviceActuallyCompletedAt == request.time &&
                 oldData.barberMarkedDoneAt == null && oldData.serviceActuallyCompletedAt == null;
        }
        if (currentStatus == 'barber-initiated-completion' && !isWalkInAppointment && nextStatus == 'completed' && isCustomerAction) {
          return newData.customerMarkedDoneAt == request.time &&
                 newData.serviceActuallyCompletedAt == request.time &&
                 oldData.customerMarkedDoneAt == null && oldData.serviceActuallyCompletedAt == null;
        }
        // Walk-in from barber-initiated-completion (or in-progress) to completed by barber action
        if ((currentStatus == 'barber-initiated-completion' || currentStatus == 'in-progress') && isWalkInAppointment && nextStatus == 'completed' && isBarberAction) {
            return newData.barberMarkedDoneAt == request.time &&
                   newData.serviceActuallyCompletedAt == request.time &&
                   (oldData.barberMarkedDoneAt == null || currentStatus == 'in-progress') && // If from in-progress, barberMarkedDoneAt was null
                   oldData.serviceActuallyCompletedAt == null;
        }
        // Cancellation by customer from upcoming or customer-initiated-check-in
        if ((currentStatus == 'upcoming' || currentStatus == 'customer-initiated-check-in') && nextStatus == 'cancelled' && isCustomerAction) {
          // Ensure no interaction timestamps are being set during cancellation
          return newData.customerCheckedInAt == oldData.customerCheckedInAt &&
                 newData.barberCheckedInAt == oldData.barberCheckedInAt &&
                 newData.serviceActuallyStartedAt == oldData.serviceActuallyStartedAt &&
                 newData.customerMarkedDoneAt == oldData.customerMarkedDoneAt &&
                 newData.barberMarkedDoneAt == oldData.barberMarkedDoneAt &&
                 newData.serviceActuallyCompletedAt == oldData.serviceActuallyCompletedAt;
        }
        // If none of the specific timestamp setting conditions match, but it's a valid status transition,
        // it means only 'status' and 'updatedAt' are changing, which is generally fine.
        // Check that all other interaction timestamps remain unchanged if they are not explicitly allowed to change.
        let interactionFields = ['customerCheckedInAt', 'barberCheckedInAt', 'serviceActuallyStartedAt', 'customerMarkedDoneAt', 'barberMarkedDoneAt', 'serviceActuallyCompletedAt'];
        return interactionFields.all(field => newData[field] == oldData[field]);
      }

      allow update: if isSignedIn() &&
                       (isCustomerForAppointment(resource.data) || isBarberForAppointment(resource.data)) &&
                       isValidAppointmentBaseData(request.resource.data) && // Check base structure of incoming data
                       areNullableInteractionTimestampsValid(request.resource.data) && // Incoming interaction timestamps are valid types
                       canTransitionStatus(resource.data.status, request.resource.data.status, isBarberForAppointment(resource.data), isCustomerForAppointment(resource.data), isWalkIn(resource.data)) &&
                       areFieldsAllowedForUpdate(request.resource.data, resource.data, resource.data.status, request.resource.data.status, isBarberForAppointment(resource.data), isCustomerForAppointment(resource.data), isWalkIn(resource.data));

      // --- DELETE ---
      allow delete: if false; // Appointments should be cancelled (status update) rather than deleted
    }
  }
}

    
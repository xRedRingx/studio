rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to get incoming data
    function incomingData() {
      return request.resource.data;
    }

    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper function to check user role from Firestore document
    function getRole(userId) {
      let userDocPath = /databases/$(database)/documents/users/$(userId);
      return exists(userDocPath) ? get(userDocPath).data.role : null;
    }

    // Helper: Is the acting user the customer for the appointment?
    function isCustomerForAppointment(appointmentData) {
      return isAuthenticated() && request.auth.uid == appointmentData.customerId;
    }

    // Helper: Is the acting user the barber for the appointment?
    function isBarberForAppointment(appointmentData) {
      return isAuthenticated() && request.auth.uid == appointmentData.barberId;
    }

    // Helper: Is the user creating their own appointment as a customer?
    function isCreatingOwnAppointmentAsCustomer() {
      return isAuthenticated() &&
             request.auth.uid == incomingData().customerId &&
             getRole(request.auth.uid) == 'customer';
    }

    // Helper: Check base fields for appointment creation by customer or walk-in by barber
    function isValidAppointmentBaseDataForCreate(data) {
      let isWalkIn = data.customerId == null;
      return data.barberId is string &&
             data.barberName is string &&
             (isWalkIn ? data.customerId == null : data.customerId is string) && // customerId is string or null for walk-in
             data.customerName is string &&
             data.serviceId is string &&
             data.serviceName is string &&
             data.price is number && data.price >= 0 &&
             data.date is string && data.date.matches('^\\d{4}-\\d{2}-\\d{2}$') &&
             data.startTime is string && data.startTime.matches('^\\d{2}:\\d{2} (AM|PM)$') &&
             data.endTime is string && data.endTime.matches('^\\d{2}:\\d{2} (AM|PM)$') &&
             (isWalkIn ? data.status == 'in-progress' : data.status == 'upcoming'); // Walk-ins start as 'in-progress'
    }

    // Helper: Validate timestamps for appointment creation
    function areTimestampsValidForCreate(data) {
      let isWalkIn = data.customerId == null;
      return data.createdAt is timestamp && data.updatedAt is timestamp && data.createdAt == data.updatedAt &&
             (isWalkIn ?
               (data.customerCheckedInAt == data.createdAt && // For walk-ins, these are set at creation
                data.barberCheckedInAt == data.createdAt &&
                data.serviceActuallyStartedAt == data.createdAt &&
                data.customerMarkedDoneAt == null &&
                data.barberMarkedDoneAt == null &&
                data.serviceActuallyCompletedAt == null)
             : // For regular customer bookings
               (data.customerCheckedInAt == null &&
                data.barberCheckedInAt == null &&
                data.serviceActuallyStartedAt == null &&
                data.customerMarkedDoneAt == null &&
                data.barberMarkedDoneAt == null &&
                data.serviceActuallyCompletedAt == null)
             );
    }

    // Helper: Ensure only allowed fields are present on creation
    function hasOnlyAllowedFieldsForCreate(data) {
      let allowedFields = [
        'barberId', 'barberName', 'customerId', 'customerName',
        'serviceId', 'serviceName', 'price', 'date', 'startTime', 'endTime',
        'status', 'createdAt', 'updatedAt',
        'customerCheckedInAt', 'barberCheckedInAt', 'serviceActuallyStartedAt',
        'customerMarkedDoneAt', 'barberMarkedDoneAt', 'serviceActuallyCompletedAt'
      ];
      return data.keys().hasOnly(allowedFields);
    }

    // Helper: Check if the barber is accepting bookings
    function isBarberAcceptingBookings(barberId) {
      let barberDocPath = /databases/$(database)/documents/users/$(barberId);
      // If barber document doesn't exist, or isAcceptingBookings is explicitly false, deny.
      // Defaults to true if field is missing.
      return exists(barberDocPath) && get(barberDocPath).data.get('isAcceptingBookings', true) == true;
    }

    // Users collection rules
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow create: if request.auth.uid == userId &&
                       request.resource.data.role in ['customer', 'barber'] &&
                       (request.resource.data.role == 'barber' ?
                         (!('isAcceptingBookings' in request.resource.data) || request.resource.data.isAcceptingBookings == true || request.resource.data.isAcceptingBookings == null) : // null also defaults to true logic in app
                         !('isAcceptingBookings' in request.resource.data)
                       ) &&
                       request.resource.data.firstName is string && request.resource.data.firstName.size() > 0 &&
                       request.resource.data.lastName is string && request.resource.data.lastName.size() > 0 &&
                       request.resource.data.email == request.auth.token.email &&
                       (!('phoneNumber' in request.resource.data) || request.resource.data.phoneNumber is string || request.resource.data.phoneNumber == null) &&
                       (!('address' in request.resource.data) || request.resource.data.address is string || request.resource.data.address == null) &&
                       request.resource.data.createdAt is timestamp && request.resource.data.updatedAt is timestamp &&
                       request.resource.data.createdAt == request.time && request.resource.data.updatedAt == request.time &&
                       (!('fcmToken' in request.resource.data) || request.resource.data.fcmToken is string || request.resource.data.fcmToken == null);

      allow update: if isAuthenticated() && request.auth.uid == userId &&
                       !('role' in incomingData()) &&
                       !('email' in incomingData()) &&
                       !('createdAt' in incomingData()) &&
                       incomingData().firstName is string && incomingData().firstName.size() > 0 &&
                       incomingData().lastName is string && incomingData().lastName.size() > 0 &&
                       (!('phoneNumber' in incomingData()) || incomingData().phoneNumber is string || incomingData().phoneNumber == null) &&
                       (!('address' in incomingData()) || incomingData().address is string || incomingData().address == null) &&
                       (getRole(userId) == 'barber' ?
                         (!('isAcceptingBookings' in incomingData()) || incomingData().isAcceptingBookings is bool) :
                         !('isAcceptingBookings' in incomingData())
                       ) &&
                       (!('fcmToken' in incomingData()) || incomingData().fcmToken is string || incomingData().fcmToken == null) &&
                       incomingData().updatedAt == request.time &&
                       incomingData().keys().hasAtLeast(['firstName', 'lastName', 'updatedAt']) && // Ensure at least these are part of update
                       incomingData().keys().hasOnly(['firstName', 'lastName', 'phoneNumber', 'address', 'isAcceptingBookings', 'fcmToken', 'updatedAt',
                                                     'uid', 'role', 'email', 'createdAt', 'displayName', 'emailVerified']); // All possible fields
    }

    // Services collection rules
    match /services/{serviceId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() &&
                       getRole(request.auth.uid) == 'barber' &&
                       incomingData().barberId == request.auth.uid &&
                       incomingData().name is string && incomingData().name.size() > 0 &&
                       incomingData().price is number && incomingData().price >= 0 &&
                       incomingData().duration is number && incomingData().duration > 0 &&
                       incomingData().createdAt == request.time &&
                       incomingData().updatedAt == request.time &&
                       incomingData().keys().hasOnly(['barberId', 'name', 'price', 'duration', 'createdAt', 'updatedAt']);
      allow update: if isAuthenticated() &&
                       getRole(request.auth.uid) == 'barber' &&
                       resource.data.barberId == request.auth.uid &&
                       !('barberId' in incomingData()) &&
                       !('createdAt' in incomingData()) &&
                       incomingData().name is string && incomingData().name.size() > 0 &&
                       incomingData().price is number && incomingData().price >= 0 &&
                       incomingData().duration is number && incomingData().duration > 0 &&
                       incomingData().updatedAt == request.time &&
                       incomingData().keys().hasAtLeast(['name', 'price', 'duration', 'updatedAt']) &&
                       incomingData().keys().hasOnly(['name', 'price', 'duration', 'updatedAt', 'barberId', 'createdAt']);
      allow delete: if isAuthenticated() &&
                       getRole(request.auth.uid) == 'barber' &&
                       resource.data.barberId == request.auth.uid;
    }

    // Barber Schedules collection rules
    match /barberSchedules/{barberId} {
      allow read: if isAuthenticated();
      allow create, update: if isAuthenticated() &&
                               request.auth.uid == barberId &&
                               getRole(request.auth.uid) == 'barber' &&
                               incomingData().barberId == barberId &&
                               incomingData().schedule is list &&
                               incomingData().updatedAt == request.time;

      match /unavailableDates/{dateId} {
        allow read: if isAuthenticated();
        allow create: if isAuthenticated() &&
                         request.auth.uid == barberId &&
                         getRole(request.auth.uid) == 'barber' &&
                         incomingData().barberId == barberId &&
                         incomingData().date == dateId &&
                         incomingData().date.matches('^\\d{4}-\\d{2}-\\d{2}$') &&
                         (!('reason' in incomingData()) || incomingData().reason is string) &&
                         incomingData().createdAt == request.time;
        allow delete: if isAuthenticated() &&
                         request.auth.uid == barberId &&
                         getRole(request.auth.uid) == 'barber';
      }
    }

    // Appointments collection rules
    match /appointments/{appointmentId} {
      allow read: if isAuthenticated() &&
                     (isCustomerForAppointment(resource.data) || isBarberForAppointment(resource.data));

      allow create: if isAuthenticated() &&
                       (
                         // Case 1: Customer creates their own appointment
                         (isCreatingOwnAppointmentAsCustomer() &&
                          isValidAppointmentBaseDataForCreate(incomingData()) &&
                          areTimestampsValidForCreate(incomingData()) && // Ensures status='upcoming' and correct nulls
                          hasOnlyAllowedFieldsForCreate(incomingData()) &&
                          isBarberAcceptingBookings(incomingData().barberId)
                         ) ||
                         // Case 2: Barber creates a walk-in appointment
                         (getRole(request.auth.uid) == 'barber' &&
                          request.auth.uid == incomingData().barberId && // Barber creating for themselves
                          incomingData().customerId == null && // Explicitly a walk-in
                          isValidAppointmentBaseDataForCreate(incomingData()) && // Ensures status='in-progress'
                          areTimestampsValidForCreate(incomingData()) && // Ensures correct timestamps for walk-in
                          hasOnlyAllowedFieldsForCreate(incomingData()) &&
                          isBarberAcceptingBookings(incomingData().barberId) // Barber must be accepting bookings (for their own walk-ins too)
                         )
                       );

      allow update: if isAuthenticated() &&
                       (isCustomerForAppointment(resource.data) || isBarberForAppointment(resource.data)) &&
                       incomingData().updatedAt == request.time &&
                       incomingData().barberId == resource.data.barberId &&
                       incomingData().barberName == resource.data.barberName &&
                       incomingData().customerId == resource.data.customerId &&
                       incomingData().customerName == resource.data.customerName &&
                       incomingData().serviceId == resource.data.serviceId &&
                       incomingData().serviceName == resource.data.serviceName &&
                       incomingData().price == resource.data.price &&
                       incomingData().date == resource.data.date &&
                       incomingData().startTime == resource.data.startTime &&
                       incomingData().endTime == resource.data.endTime &&
                       incomingData().createdAt == resource.data.createdAt &&
                       (
                         (resource.data.status == 'upcoming' && incomingData().status == 'customer-initiated-check-in' && isCustomerForAppointment(resource.data) &&
                           incomingData().customerCheckedInAt == request.time &&
                           (!('barberCheckedInAt' in incomingData()) || incomingData().barberCheckedInAt == resource.data.barberCheckedInAt) && // Ensure not changed if already set
                           (!('serviceActuallyStartedAt' in incomingData()) || incomingData().serviceActuallyStartedAt == resource.data.serviceActuallyStartedAt) &&
                           incomingData().keys().hasAny(['status', 'updatedAt', 'customerCheckedInAt'])) ||

                         (resource.data.status == 'upcoming' && incomingData().status == 'barber-initiated-check-in' && isBarberForAppointment(resource.data) &&
                           incomingData().barberCheckedInAt == request.time &&
                           (!('customerCheckedInAt' in incomingData()) || incomingData().customerCheckedInAt == resource.data.customerCheckedInAt) &&
                           (!('serviceActuallyStartedAt' in incomingData()) || incomingData().serviceActuallyStartedAt == resource.data.serviceActuallyStartedAt) &&
                           incomingData().keys().hasAny(['status', 'updatedAt', 'barberCheckedInAt'])) ||

                         (resource.data.status == 'customer-initiated-check-in' && incomingData().status == 'in-progress' && isBarberForAppointment(resource.data) &&
                           resource.data.customerCheckedInAt != null &&
                           incomingData().barberCheckedInAt == request.time &&
                           incomingData().serviceActuallyStartedAt == request.time &&
                           incomingData().keys().hasAny(['status', 'updatedAt', 'barberCheckedInAt', 'serviceActuallyStartedAt'])) ||

                         (resource.data.status == 'barber-initiated-check-in' && resource.data.customerId != null && incomingData().status == 'in-progress' && isCustomerForAppointment(resource.data) &&
                           resource.data.barberCheckedInAt != null &&
                           incomingData().customerCheckedInAt == request.time &&
                           incomingData().serviceActuallyStartedAt == request.time &&
                           incomingData().keys().hasAny(['status', 'updatedAt', 'customerCheckedInAt', 'serviceActuallyStartedAt'])) ||

                         // Barber starting a walk-in that was somehow created as barber-initiated-check-in (should ideally be in-progress from start)
                         (resource.data.status == 'barber-initiated-check-in' && resource.data.customerId == null && incomingData().status == 'in-progress' && isBarberForAppointment(resource.data) &&
                           incomingData().serviceActuallyStartedAt == request.time && // barberCheckedInAt and customerCheckedInAt already set for walk-in
                           incomingData().keys().hasAny(['status', 'updatedAt', 'serviceActuallyStartedAt'])) ||


                         (resource.data.status == 'in-progress' && incomingData().status == 'customer-initiated-completion' && isCustomerForAppointment(resource.data) &&
                           incomingData().customerMarkedDoneAt == request.time &&
                           incomingData().keys().hasAny(['status', 'updatedAt', 'customerMarkedDoneAt'])) ||

                         (resource.data.status == 'in-progress' && incomingData().status == 'barber-initiated-completion' && isBarberForAppointment(resource.data) &&
                           incomingData().barberMarkedDoneAt == request.time &&
                           incomingData().keys().hasAny(['status', 'updatedAt', 'barberMarkedDoneAt'])) ||

                         (resource.data.status == 'customer-initiated-completion' && incomingData().status == 'completed' && isBarberForAppointment(resource.data) &&
                           resource.data.customerMarkedDoneAt != null &&
                           incomingData().barberMarkedDoneAt == request.time &&
                           incomingData().serviceActuallyCompletedAt == request.time &&
                           incomingData().keys().hasAny(['status', 'updatedAt', 'barberMarkedDoneAt', 'serviceActuallyCompletedAt'])) ||

                         (resource.data.status == 'barber-initiated-completion' && resource.data.customerId != null && incomingData().status == 'completed' && isCustomerForAppointment(resource.data) &&
                           resource.data.barberMarkedDoneAt != null &&
                           incomingData().customerMarkedDoneAt == request.time &&
                           incomingData().serviceActuallyCompletedAt == request.time &&
                           incomingData().keys().hasAny(['status', 'updatedAt', 'customerMarkedDoneAt', 'serviceActuallyCompletedAt'])) ||

                         (resource.data.status == 'in-progress' && resource.data.customerId == null && incomingData().status == 'completed' && isBarberForAppointment(resource.data) &&
                           incomingData().barberMarkedDoneAt == request.time &&
                           incomingData().serviceActuallyCompletedAt == request.time &&
                           incomingData().keys().hasAny(['status', 'updatedAt', 'barberMarkedDoneAt', 'serviceActuallyCompletedAt'])) ||

                         (resource.data.status in ['upcoming', 'customer-initiated-check-in', 'barber-initiated-check-in'] && incomingData().status == 'cancelled' && isCustomerForAppointment(resource.data) &&
                           incomingData().keys().hasAny(['status', 'updatedAt']))
                       ) &&
                       // Ensure only allowed fields are part of the request for any update.
                       // This is a bit broad, but specific transitions narrow it down with hasAny.
                       incomingData().keys().hasOnly([
                         'status', 'updatedAt',
                         'customerCheckedInAt', 'barberCheckedInAt', 'serviceActuallyStartedAt',
                         'customerMarkedDoneAt', 'barberMarkedDoneAt', 'serviceActuallyCompletedAt',
                         // Immutable fields that must be present in incomingData() to match resource.data
                         'barberId', 'barberName', 'customerId', 'customerName',
                         'serviceId', 'serviceName', 'price', 'date', 'startTime', 'endTime', 'createdAt'
                       ]);
    }
  }
}

    